---
title: "DEanalysis"
----v
---

<https://hbctraining.github.io/Intro-to-DGE/schedule/links-to-lessons.html>

## Setup und Pakete

L√§dt alle ben√∂tigten R-Pakete f√ºr die Analyse: DESeq2, tximport, clusterProfiler, tidyverse, pheatmap, etc.

```{r}
#| label: setup-packages
#| echo: false
#| warning: false

#Pakete werden aus Setup Skript geladen
source("../../org/setup_packages.R")

suppressPackageStartupMessages(
{library(tidyverse)  
library(readxl)
library(janitor)
library(DESeq2)
library(tximport)
library(pheatmap)
library(RColorBrewer)
library(ggrepel)
library(cowplot)
library(DEGreport)
library(clusterProfiler)
library(DOSE)
library(org.Hs.eg.db)
library(pathview)
library(AnnotationHub)
library(ensembldb)
library(apeglm)
library(ashr)
})
sessionInfo()
```

## Datenimport und Vorbereitung

Dieser Chunk importiert die Salmon-Quantifizierungen mittels `tximport`, liest die Metadata aus Excel ein, f√ºhrt Quality Checks durch und erstellt ein Subset nur f√ºr Aortenklappen-Samples.

```{r}
#| echo: false
#| warning: false
# Pfade
salmon <- "../../dat/salmon_files"
tx2g   <- "../../dat/info_files/tx2gene.tsv"
excel  <- "../../dat/info_files/CCGA_sequencing_NM_ventricular_dysfunction_RNAseq_2342.xlsx"

# Salmon-Files einlesen
files <- list.files(
  path      = salmon,
  full.names = TRUE,
  pattern   = "_quant\\.sf$"
)

# Saubere Namen f√ºr tximport
names(files) <- basename(files) %>%
  str_remove("_quant\\.sf$") %>%    # Endung entfernen
  str_remove("-L[0-9]+$")           # evtl. Library-Nummer entfernen

# Duplikate ausschlie√üen
stopifnot(length(files) > 1)
stopifnot(!anyDuplicated(names(files)))

# tx2gene einlesen
tx2gene <- read.delim(tx2g)
tx2gene[,1] <- sub("\\..*$", "", tx2gene[,1])  # Versionsnummer entfernen
tx2gene <- tx2gene[, c(1,2)]                    # Nur tx_id und gene_id

# tximport
txi_cache <- "../../res/cache/txi_salmon_tximport.rds"
dir.create(dirname(txi_cache), recursive = TRUE, showWarnings = FALSE)

if (file.exists(txi_cache)) {
  message("‚úÖ Lade tximport Cache: ", txi_cache)
  txi <- readRDS(txi_cache)
} else {
  message("‚è≥ Rechne tximport‚Ä¶")
  txi <- tximport(
    files,
    type = "salmon",
    tx2gene = tx2gene,
    countsFromAbundance = "lengthScaledTPM",
    ignoreTxVersion = TRUE
  )
  saveRDS(txi, txi_cache)
  message("üíæ Gespeichert: ", txi_cache)
}

# Sample-Namen in txi bereinigen
colnames(txi$counts)    <- str_remove(colnames(txi$counts), "_quant\\.sf$")
colnames(txi$abundance) <- str_remove(colnames(txi$abundance), "_quant\\.sf$")
colnames(txi$length)    <- str_remove(colnames(txi$length), "_quant\\.sf$")

# Metadata einlesen
md <- read_excel(excel, sheet = "Metadata", skip = 1) %>%
  janitor::clean_names() %>%
  mutate(sample_id = str_remove(library_id, "-L[0-9]+$") %>% str_trim())

input <- read_excel(excel, sheet = 3, skip = 1) %>%
  janitor::clean_names() %>%
  mutate(
    valve_treated = if_else(str_starts(sample_name, regex("^t", TRUE)),
                            "tricuspid valve",
                            "aortic valve"),
    timepoint = str_extract(sample_name, "(?<=_).*"),
    pid       = str_extract(sample_name, "^[^_]+")
  ) %>%
  dplyr::select(external_id, valve_treated, timepoint, pid)

md <- left_join(md, input, by = "external_id")
stopifnot(all(!is.na(md$valve_treated)))

# ============================================================
# Diagnostik: Counts-Samples vs. Metadata-Samples
# ============================================================
counts_samples <- colnames(txi$counts)

in_counts_not_meta <- setdiff(counts_samples, md$sample_id)
in_meta_not_counts <- setdiff(md$sample_id, counts_samples)

message("Samples in counts but not metadata: ", length(in_counts_not_meta))
message("Samples in metadata but not counts: ", length(in_meta_not_counts))

if (length(in_counts_not_meta) > 0) {
  message("‚Üí In counts, not in metadata:")
  print(in_counts_not_meta)
}

if (length(in_meta_not_counts) > 0) {
  message("‚Üí In metadata, not in counts:")
  print(in_meta_not_counts)
}

# Abbrechen, wenn es Mismatches gibt
stopifnot(length(in_counts_not_meta) == 0, length(in_meta_not_counts) == 0)


# Nur Aorten-Samples behalten
keep_aortic <- intersect(colnames(txi$counts),
                         md$sample_id[md$valve_treated == "aortic valve"])

stopifnot(length(keep_aortic) > 1)
stopifnot(!anyDuplicated(keep_aortic))

txi_aortic <- list(
  counts             = txi$counts[, keep_aortic, drop = FALSE],
  abundance          = txi$abundance[, keep_aortic, drop = FALSE],
  length             = txi$length[, keep_aortic, drop = FALSE],
  countsFromAbundance = txi$countsFromAbundance
)


md_aortic <- md[md$sample_id %in% keep_aortic, ]

cat("Anzahl Aorten-Samples:", length(keep_aortic), "\n")
head(md_aortic)


```

## Explorative Datenanalyse (EDA)

Dieser Chunk visualisiert die Count-Verteilung und die Mean-Variance-Beziehung der RNA-seq Daten. Der Mean-Variance Plot zeigt Overdispersion (Varianz \>\> Mittelwert), was die Verwendung von Negativ-Binomial-Modellen (DESeq2) rechtfertigt.

```{r}
#| label: eda-counts
#| echo: false
#| warning: false

# Die Count-Verteilung einer einzelnen Probe ansehen
counts_aortic <- as.data.frame(txi_aortic$counts)

sample <- colnames(counts_aortic)[1]

ggplot(counts_aortic) +
  geom_histogram(aes(x = .data[[sample]]), bins = 200) +
  xlab("Raw expression counts") +
  ylab("Number of genes")

# Mean‚ÄìVariance Plot (RNA-seq count data) f√ºr Aorten-Counts

# 2) Mean und Varianz pro Gen (√ºber alle ausgew√§hlten Samples/Spalten)
mean_counts     <- apply(counts_aortic, 1, mean, na.rm = TRUE)  # '1' = zeilenweise (Gene)
variance_counts <- apply(counts_aortic, 1, var,  na.rm = TRUE)

# 3) Dataframe f√ºr ggplot
df_mv <- data.frame(
  mean_counts = mean_counts,
  variance_counts = variance_counts
)

# Gene mit mean/var <= 0 entfernen (log10 braucht > 0)
df_mv <- dplyr::filter(
  df_mv,
  mean_counts > 0,
  variance_counts > 0
)

# 4) Plot: log10-mean vs log10-variance, rote Linie = x=y
ggplot(df_mv) +
  geom_point(aes(x = mean_counts, y = variance_counts), alpha = 0.4) +
  scale_x_log10() +
  scale_y_log10() +
  geom_abline(intercept = 0, slope = 1, color = "red") +
  labs(
    title = "Mean‚ÄìVariance Relationship (Aortic valve RNA-seq counts)",
    x = "Mean of counts per gene (log10)",
    y = "Variance of counts per gene (log10)"
  )
# Daten passen nicht zur Poission-Verteilung, weil die Varianz >> Mittelwert (Overdispersion). Besonders bei h√∂her exprimierten Genene ist die Varianz viel gr√∂√üer. Das rechtfertigt die Verwendung der Negativ-Binomial-Modelle von DESeq2
```

## DESeq2 Normalisierung

Dieser Chunk erstellt das DESeqDataSet-Objekt, f√ºhrt Prefiltering durch (rowSums \>= 10), sch√§tzt Size Factors mittels median-of-ratios Methode und exportiert normalisierte Counts. Die normalisierten Counts dienen nur der Visualisierung/QC, nicht als Input f√ºr DE-Tests.

```{r}
#| label: deseq2-normalization
#| echo: false
#| warning: false

# ------------------------------------------------------------
# 1) Metadata f√ºr DESeq2 vorbereiten
#    - sample_id muss character sein (IDs)
#    - pid/timepoint als factor (Design-Variablen)
#    - rownames(meta) m√ºssen exakt die Sample-IDs sein
# ------------------------------------------------------------
meta <- md_aortic %>%
  mutate(
    sample_id = as.character(sample_id),
    pid       = factor(pid),        # Patient-ID
    timepoint = factor(timepoint)   
  ) %>%
  as.data.frame()

rownames(meta) <- meta$sample_id

# ------------------------------------------------------------
# 2) Sicherstellen, dass Counts-Spalten und Metadata-Zeilen matchen
#    DESeq2 verlangt:
#      colnames(counts) == rownames(colData)
#    Reihenfolge ist wichtig (sonst falsche Zuordnung)
# ------------------------------------------------------------

# Check: alle Count-Sample-IDs existieren in meta?
stopifnot(all(colnames(txi_aortic$counts) %in% rownames(meta)))

# Meta exakt in die Reihenfolge der Count-Spalten bringen
meta <- meta[match(colnames(txi_aortic$counts), rownames(meta)), , drop = FALSE]

# Check: jetzt exakt identisch und in gleicher Reihenfolge?
stopifnot(all(colnames(txi_aortic$counts) == rownames(meta)))

# ------------------------------------------------------------
# 3) tximport-Metainfo erhalten
#    DESeqDataSetFromTximport() erwartet u.a. txi$countsFromAbundance
#    Wenn txi_aortic manuell als Liste gebaut wurde, fehlt das
# ------------------------------------------------------------
txi_aortic$countsFromAbundance <- txi$countsFromAbundance

# ------------------------------------------------------------
# 4) DESeqDataSet erstellen
#    Design: ~ pid + timepoint
#    - pid modelliert patientenspezifische Baselines
#    - timepoint testet die systematische √Ñnderung √ºber die Zeit
# ------------------------------------------------------------
dds <- DESeqDataSetFromTximport(
  txi = txi_aortic,
  colData = meta,
  design = ~ pid + timepoint
)

# ------------------------------------------------------------
# 5) Prefiltering:
#    Entfernt Gene mit extrem niedrigen Counts in allen Samples,
#    verbessert Laufzeit und reduziert Noise.
# ------------------------------------------------------------
dds <- dds[rowSums(counts(dds)) >= 10, ]

# ------------------------------------------------------------
# 6) Normalisierung: Size Factors sch√§tzen
#    DESeq2 nutzt "median-of-ratios" (robust gegen Outlier/Geneffekte)
# ------------------------------------------------------------
dds <- estimateSizeFactors(dds)

# Size factors inspizieren (sollten grob um 1 liegen; Unterschiede = Library size etc.)
sf <- sizeFactors(dds)
print(sf)

# ------------------------------------------------------------
# 7) Normalisierte Counts extrahieren
#    Diese Matrix ist sinnvoll f√ºr:
#      - PCA / Heatmaps / Plots
#    NICHT sinnvoll als Input f√ºr DESeq2-DE-Tests (die arbeiten mit Rohcounts + Modell)
# ------------------------------------------------------------
normalized_counts <- counts(dds, normalized = TRUE)

# ------------------------------------------------------------
# 8) Speichern
# ------------------------------------------------------------
write.table(
  normalized_counts,
  file = "../../res/normalized_counts_aortic_DESeq2.tsv",
  sep = "\t",
  quote = FALSE,
  col.names = NA
)
```

## Quality Control (QC)

Dieser Chunk f√ºhrt QC-Analysen durch: Varianz-stabilisierende Transformation (VST), PCA-Plots (PC1/2 und PC3/4) zur Visualisierung der Sample-√Ñhnlichkeit, sowie eine Korrelations-Heatmap.

**Erwartete Beobachtungen:** - PCAs clustern prim√§r nach Patient (nicht Timepoint), da der Patienteneffekt \> Timepoint-Effekt - Hohe Sample-Korrelationen (\>0.9) sprechen f√ºr technisch saubere Daten

```{r}
#| label: qc-vst-pca
#| echo: false
#| warning: false

# Varianz-stabilisierende Transformation (blind = TRUE f√ºr QC)
vst_data <- vst(dds, blind = TRUE)
vst_mat <- assay(vst_data)

# PCA berechnen (einmalig f√ºr alle Plots)
pca_result <- prcomp(t(vst_mat))
pca_var <- round(100 * pca_result$sdev^2 / sum(pca_result$sdev^2), 1)

# PCA-Daten mit Metadaten kombinieren
pca_df <- cbind(
  as.data.frame(colData(dds)[, c("timepoint", "pid")]),
  as.data.frame(pca_result$x)
)

# PCA Plot: PC1 vs PC2 (Linien verbinden Zeitpunkte pro Patient)
ggplot(pca_df, aes(x = PC1, y = PC2, color = timepoint, group = pid)) +
  geom_line(color = "grey60", alpha = 0.5) +
  geom_point(size = 3) +
  labs(
    x = paste0("PC1 (", pca_var[1], "%)"),
    y = paste0("PC2 (", pca_var[2], "%)"),
    title = "PCA: PC1 vs PC2",
    color = "Zeitpunkt"
  ) +
  theme_bw()

# PCA Plot: PC3 vs PC4
ggplot(pca_df, aes(x = PC3, y = PC4, color = timepoint, group = pid)) +
  geom_line(color = "grey60", alpha = 0.5) +
  geom_point(size = 3) +
  labs(
    x = paste0("PC3 (", pca_var[3], "%)"),
    y = paste0("PC4 (", pca_var[4], "%)"),
    title = "PCA: PC3 vs PC4",
    color = "Zeitpunkt"
  ) +
  theme_bw()

# Sample-Korrelations-Heatmap
sample_cor <- cor(vst_mat)

heatmap_anno <- as.data.frame(colData(dds)[, c("timepoint", "pid"), drop = FALSE])
heatmap_anno$timepoint <- factor(heatmap_anno$timepoint)
heatmap_anno$pid <- factor(heatmap_anno$pid)
heatmap_anno <- heatmap_anno[match(colnames(sample_cor), rownames(heatmap_anno)), , drop = FALSE]

pheatmap(
  sample_cor,
  annotation_col = heatmap_anno,
  show_colnames = FALSE,
  show_rownames = FALSE,
  breaks = seq(0.9, 1, length.out = 100),
  main = "Sample-Korrelation (Pearson)",
  border_color = NA
)
```

## DESeq2 Differentielle Expression (Wald-Tests)

Dieser Chunk f√ºhrt die Wald-Tests f√ºr paarweise Vergleiche durch (V1 vs A, V2 vs A, V2 vs V1) mit RDS-Caching. Zus√§tzlich werden LFC-Shrinkage-Ergebnisse mit apeglm/ashr berechnet.

```{r}
#| label: deseq2-wald-tests
#| echo: false
#| warning: false

# Verzeichnisse
cache_dir <- "../../res/cache"
res_dir <- "../../res"
dir.create(cache_dir, recursive = TRUE, showWarnings = FALSE)
dir.create(res_dir, recursive = TRUE, showWarnings = FALSE)

alpha_level <- 0.05

# Helper: RDS-Caching mit optionalem CSV-Export
load_or_compute <- function(rds_path, compute_fn, csv_path = NULL) {
  if (file.exists(rds_path)) {
    message("Lade: ", basename(rds_path))
    return(readRDS(rds_path))
  }
  message("Berechne: ", basename(rds_path))
  result <- compute_fn()
  saveRDS(result, rds_path)
  if (!is.null(csv_path)) write.csv(as.data.frame(result), csv_path)
  result
}

# Fitted DESeq2-Objekt laden/berechnen
dds_cache <- file.path(cache_dir, "dds_DESeq_fitted.rds")

dds <- load_or_compute(dds_cache, function() {
  colData(dds)$timepoint <- factor(colData(dds)$timepoint, levels = c("A", "V1", "V2"))
  design(dds) <- ~ pid + timepoint
  dds <- dds[rowSums(counts(dds)) >= 10, ]
  DESeq(dds)
})

# Kontrast-Definitionen
contrasts <- list(
  V1_vs_A  = list(contrast = c("timepoint", "V1", "A"),  coef = "timepoint_V1_vs_A",  shrink = "apeglm"),
  V2_vs_A  = list(contrast = c("timepoint", "V2", "A"),  coef = "timepoint_V2_vs_A",  shrink = "apeglm"),
  V2_vs_V1 = list(contrast = c("timepoint", "V2", "V1"), coef = NULL,                 shrink = "ashr")
)

# Results und Shrinkage f√ºr alle Kontraste berechnen
wald_results <- list()
shrink_results <- list()

for (name in names(contrasts)) {
  cfg <- contrasts[[name]]

  # Wald-Test Results
  wald_results[[name]] <- load_or_compute(
    rds_path = file.path(cache_dir, paste0("DESeq2_results_", name, ".rds")),
    csv_path = file.path(res_dir, paste0("DESeq2_results_", name, ".csv")),
    compute_fn = function() results(dds, contrast = cfg$contrast, alpha = alpha_level)
  )

  # LFC Shrinkage
  shrink_results[[name]] <- load_or_compute(
    rds_path = file.path(cache_dir, paste0("DESeq2_LFCshrink_", name, ".rds")),
    csv_path = file.path(res_dir, paste0("DESeq2_LFCshrink_", name, ".csv")),
    compute_fn = function() {
      if (!is.null(cfg$coef)) {
        lfcShrink(dds, coef = cfg$coef, res = wald_results[[name]], type = cfg$shrink)
      } else {
        lfcShrink(dds, contrast = cfg$contrast, res = wald_results[[name]], type = cfg$shrink)
      }
    }
  )
}

# F√ºr Abw√§rtskompatibilit√§t: Einzelne Variablen erstellen
res_V1_vs_A    <- wald_results$V1_vs_A
res_V2_vs_A    <- wald_results$V2_vs_A
res_V2_vs_V1   <- wald_results$V2_vs_V1
resLFC_V1_vs_A  <- shrink_results$V1_vs_A
resLFC_V2_vs_A  <- shrink_results$V2_vs_A
resLFC_V2_vs_V1 <- shrink_results$V2_vs_V1
```

## Dispersionskurve

Visualisierung der Dispersionssch√§tzung. Die Kurve zeigt keine Auff√§lligkeiten (Batch-Effekte, Fehlanpassung).

```{r}
#| label: dispersion-plot
#| echo: false
#| warning: false

plotDispEsts(dds)
```

## MA-Plots (Shrinkage-Vergleich)

Vergleich der unshrunken vs. shrunken Log2 Fold Changes mittels MA-Plots f√ºr alle drei Kontraste. Shrinkage reduziert Noise bei niedrig exprimierten Genen.

```{r}
#| label: ma-plots-shrinkage
#| echo: false
#| warning: false

for (name in names(wald_results)) {
  label <- gsub("_", " ", name)

  DESeq2::plotMA(wald_results[[name]], ylim = c(-2, 2), main = paste(label, "‚Äì unshrunken"))
  DESeq2::plotMA(shrink_results[[name]], ylim = c(-2, 2), main = paste(label, "‚Äì shrunken"))
}
```

## Wald-Ergebnisse Zusammenfassung

Zusammenfassung der Wald-Test-Ergebnisse: Konvertierung zu Tibbles, Filterung signifikanter Gene (padj \< 0.05), Z√§hlung up/down-regulierter Gene.

```{r}
#| label: wald-results-summary
#| echo: false
#| warning: false

padj_cutoff <- 0.05

# Summary f√ºr alle Kontraste
for (name in names(wald_results)) {
  cat("\n===", gsub("_", " ", name), "===\n")
  summary(wald_results[[name]], alpha = padj_cutoff)
}

# Helper: DESeqResults ‚Üí Tibble
results_to_tibble <- function(res) {
  res |>
    as.data.frame() |>
    rownames_to_column(var = "gene") |>
    as_tibble()
}

# Konvertiere alle Results zu Tibbles
results_tb <- lapply(wald_results, results_to_tibble)

# Filtere signifikante Gene
sig_results <- lapply(results_tb, function(tb) {
  dplyr::filter(tb, !is.na(padj), padj < padj_cutoff)
})

# √úbersichtstabelle: Up/Down pro Kontrast
overview <- map_dfr(names(sig_results), function(name) {
  sig <- sig_results[[name]]
  tibble(
    comparison = gsub("_", " ", name),
    n_sig = nrow(sig),
    n_up = sum(sig$log2FoldChange > 0, na.rm = TRUE),
    n_down = sum(sig$log2FoldChange < 0, na.rm = TRUE)
  )
})

overview

# F√ºr Abw√§rtskompatibilit√§t: Einzelne Variablen
res_V1_vs_A_tb  <- results_tb$V1_vs_A
res_V2_vs_A_tb  <- results_tb$V2_vs_A
res_V2_vs_V1_tb <- results_tb$V2_vs_V1

sig_V1_vs_A  <- sig_results$V1_vs_A
sig_V2_vs_A  <- sig_results$V2_vs_A
sig_V2_vs_V1 <- sig_results$V2_vs_V1
```

## Visualisierungen und Genannotation

Dieser Chunk erstellt Visualisierungen der DE-Ergebnisse: Genannotation (Ensembl ‚Üí SYMBOL/GENENAME), Top-20 Expressionsplots, Volcano Plots und Heatmaps signifikanter Gene.

```{r}
#| label: de-visualizations
#| echo: false
#| warning: false

# Metadaten vorbereiten
sample_meta <- meta |>
  rownames_to_column(var = "samplename") |>
  as_tibble() |>
  mutate(condition = droplevels(timepoint))

stopifnot(all(sample_meta$samplename %in% colnames(normalized_counts)))

# Normalisierte Counts als Tibble
norm_counts_tb <- normalized_counts |>
  as.data.frame() |>
  rownames_to_column(var = "gene") |>
  as_tibble()

# Genannotation: Ensembl ‚Üí SYMBOL/GENENAME
strip_ensembl_version <- function(x) sub("\\..*$", "", x)

all_ensembl <- unique(unlist(lapply(results_tb, function(tb) strip_ensembl_version(tb$gene))))

gene_anno <- AnnotationDbi::select(
  org.Hs.eg.db,
  keys = all_ensembl,
  keytype = "ENSEMBL",
  columns = c("SYMBOL", "GENENAME")
) |>
  as_tibble() |>
  rename(ensembl_id = ENSEMBL) |>
  arrange(ensembl_id, desc(!is.na(SYMBOL))) |>
  distinct(ensembl_id, .keep_all = TRUE)

# Annotation hinzuf√ºgen
add_gene_symbols <- function(tb) {
  tb |>
    mutate(ensembl_id = strip_ensembl_version(gene)) |>
    left_join(gene_anno, by = "ensembl_id")
}

results_annot <- lapply(results_tb, add_gene_symbols)
sig_annot <- lapply(sig_results, add_gene_symbols)

# Kontrast-Konfiguration f√ºr Plots
contrast_config <- list(
  V1_vs_A  = list(label = "V1 vs A",  keep_levels = c("A", "V1")),
  V2_vs_A  = list(label = "V2 vs A",  keep_levels = c("A", "V2")),
  V2_vs_V1 = list(label = "V2 vs V1", keep_levels = c("V1", "V2"))
)

# Plot-Funktionen
plot_top20_expression <- function(res_tb, meta_tb, title = NULL) {
  top_genes <- res_tb |>
    dplyr::filter(!is.na(padj), padj < padj_cutoff) |>
    arrange(padj) |>
    slice_head(n = 20) |>
    pull(gene)

  plot_df <- norm_counts_tb |>
    dplyr::filter(gene %in% top_genes) |>
    pivot_longer(cols = -gene, names_to = "samplename", values_to = "norm_count") |>
    inner_join(meta_tb, by = "samplename")

  ggplot(plot_df, aes(x = gene, y = norm_count + 1, color = condition)) +
    geom_point(position = position_jitter(width = 0.15), alpha = 0.8) +
    scale_y_log10() +
    labs(title = title, x = NULL, y = "Normalisierte Counts (log10, +1)", color = "Zeitpunkt") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1), panel.grid.minor = element_blank())
}

plot_volcano <- function(res_tb, title = NULL) {
  plot_df <- res_tb |>
    dplyr::filter(!is.na(padj)) |>
    mutate(neg_log10_padj = -log10(padj), sig = padj < padj_cutoff)

  ggplot(plot_df, aes(x = log2FoldChange, y = neg_log10_padj)) +
    geom_point(aes(color = sig), alpha = 0.6, size = 1.2) +
    scale_color_manual(values = c("FALSE" = "grey70", "TRUE" = "red")) +
    geom_hline(yintercept = -log10(padj_cutoff), linetype = "dashed") +
    labs(title = title, x = "log2 Fold Change", y = "-log10(padj)", color = paste0("padj < ", padj_cutoff)) +
    theme_bw()
}

plot_sig_heatmap <- function(sig_genes, keep_levels, main = NULL) {
  samples_keep <- sample_meta |> dplyr::filter(condition %in% keep_levels) |> dplyr::pull(samplename)
  mat <- normalized_counts[rownames(normalized_counts) %in% sig_genes, samples_keep, drop = FALSE]

  if (nrow(mat) == 0) return(NULL)

  anno <- sample_meta |> dplyr::filter(samplename %in% colnames(mat)) |> dplyr::select(condition) |> as.data.frame()
  rownames(anno) <- sample_meta |> dplyr::filter(samplename %in% colnames(mat)) |> dplyr::pull(samplename)

  pheatmap(mat, color = brewer.pal(6, "YlOrRd"), cluster_rows = TRUE, cluster_cols = TRUE,
           show_rownames = FALSE, annotation_col = anno, border_color = NA, scale = "row", main = main)
}

# Plots erstellen
for (name in names(contrast_config)) {
  cfg <- contrast_config[[name]]
  meta_sub <- sample_meta |> dplyr::filter(condition %in% cfg$keep_levels) |> droplevels()

  print(plot_top20_expression(results_tb[[name]], meta_sub, paste("Top 20 DE-Gene:", cfg$label)))
  print(plot_volcano(results_tb[[name]], paste("Volcano Plot:", cfg$label)))
  plot_sig_heatmap(sig_results[[name]]$gene, cfg$keep_levels, paste("Heatmap:", cfg$label))
}

# Top 20 Tabellen mit Annotation
top20_tables <- lapply(names(sig_annot), function(name) {
  sig_annot[[name]] |>
    dplyr::filter(!is.na(padj)) |>
    arrange(padj) |>
    slice_head(n = 20) |>
    dplyr::select(gene, ensembl_id, SYMBOL, GENENAME, log2FoldChange, padj)
})
names(top20_tables) <- names(sig_annot)

top20_tables

# Abw√§rtskompatibilit√§t
res_V1_vs_A_annot <- results_annot$V1_vs_A
res_V2_vs_A_annot <- results_annot$V2_vs_A
res_V2_vs_V1_annot <- results_annot$V2_vs_V1
sig_V1_vs_A_annot <- sig_annot$V1_vs_A
sig_V2_vs_A_annot <- sig_annot$V2_vs_A
sig_V2_vs_V1_annot <- sig_annot$V2_vs_V1
```

## LRT-Analyse (Likelihood Ratio Test)

Likelihood Ratio Test f√ºr den globalen Timepoint-Effekt (Full: `~ pid + timepoint`, Reduced: `~ pid`). Identifiziert Gene, die sich √ºber alle Zeitpunkte hinweg signifikant √§ndern. Mit RDS-Caching.

```{r}
#| label: lrt-analysis
#| echo: false
#| warning: false

# Cache-Pfade f√ºr LRT
dds_lrt_cache_file <- file.path(cache_dir, "dds_DESeq_LRT_fitted.rds")
res_lrt_rds        <- file.path(cache_dir, "DESeq2_results_LRT_timepoint.rds")
res_lrt_csv        <- file.path(res_dir, "DESeq2_results_LRT_timepoint.csv")

# LRT-fitted dds laden oder berechnen
if (file.exists(dds_lrt_cache_file)) {
  message("Lade LRT-DESeq2-Objekt: ", dds_lrt_cache_file)
  dds_lrt <- readRDS(dds_lrt_cache_file)
} else {
  message("Berechne DESeq2 LRT‚Ä¶")
  dds_lrt <- dds
  colData(dds_lrt)$timepoint <- factor(colData(dds_lrt)$timepoint, levels = c("A", "V1", "V2"))
  design(dds_lrt) <- ~ pid + timepoint
  dds_lrt <- dds_lrt[rowSums(counts(dds_lrt)) >= 10, ]
  dds_lrt <- DESeq(dds_lrt, test = "LRT", reduced = ~ pid)
  saveRDS(dds_lrt, dds_lrt_cache_file)
}

# LRT-Results laden oder berechnen (nutzt load_or_compute aus Wald-Chunk)
res_lrt <- load_or_compute(
  rds_path = res_lrt_rds,
  csv_path = res_lrt_csv,
  compute_fn = function() results(dds_lrt, alpha = 0.05)
)

summary(res_lrt)
```

## LRT-Ergebnisse Visualisierung

Weiterverarbeitung der LRT-Ergebnisse: Annotation mit SYMBOL/GENENAME, Filterung signifikanter Gene (padj \< 0.05, Top 200), und Heatmap √ºber alle Zeitpunkte (A/V1/V2).

```{r}
#| label: lrt-visualization
#| echo: false
#| warning: false

# LRT-Results -> Tibble mit Annotation
res_lrt_tb <- res_lrt |>
  as.data.frame() |>
  rownames_to_column(var = "gene") |>
  as_tibble() |>
  mutate(ensembl_id = strip_ensembl_version(gene))

# Annotation f√ºr LRT-Gene (einige k√∂nnten neu sein)
lrt_ensembl_ids <- unique(res_lrt_tb$ensembl_id)
new_ids <- setdiff(lrt_ensembl_ids, gene_anno$ensembl_id)

if (length(new_ids) > 0) {
  new_anno <- AnnotationDbi::select(
    org.Hs.eg.db, keys = new_ids, keytype = "ENSEMBL", columns = c("SYMBOL", "GENENAME")
  ) |> as_tibble() |> rename(ensembl_id = ENSEMBL) |>
    arrange(ensembl_id, desc(!is.na(SYMBOL))) |>
    distinct(ensembl_id, .keep_all = TRUE)
  gene_anno <- bind_rows(gene_anno, new_anno)
}

res_lrt_annot <- res_lrt_tb |> left_join(gene_anno, by = "ensembl_id")

# Signifikante LRT-Gene (Top 200)
n_heatmap <- 200
sig_lrt <- res_lrt_annot |>
  dplyr::filter(!is.na(padj), padj < padj_cutoff) |>
  arrange(padj) |>
  slice_head(n = n_heatmap)

sig_lrt |> dplyr::select(gene, ensembl_id, SYMBOL, GENENAME, pvalue, padj) |> slice_head(n = 20)

# Heatmap der LRT-signifikanten Gene
mat_lrt <- normalized_counts[
  strip_ensembl_version(rownames(normalized_counts)) %in% sig_lrt$ensembl_id, , drop = FALSE
]
rownames(mat_lrt) <- strip_ensembl_version(rownames(mat_lrt))
mat_lrt <- mat_lrt[intersect(sig_lrt$ensembl_id, rownames(mat_lrt)), , drop = FALSE]

annotation_col <- sample_meta |> dplyr::select(samplename, condition) |> as.data.frame()
rownames(annotation_col) <- annotation_col$samplename
annotation_col$samplename <- NULL

pheatmap(mat_lrt, color = brewer.pal(6, "YlOrRd"), cluster_rows = TRUE, cluster_cols = TRUE,
         show_rownames = FALSE, annotation_col = annotation_col, border_color = NA,
         fontsize = 10, scale = "row", main = paste0("LRT signifikante Gene (padj < ", padj_cutoff, ")"))
```

## Wald vs. LRT Overlap

Berechnung des Overlaps zwischen LRT-signifikanten Genen (global) und Wald-signifikanten Genen (paarweise Kontraste). Identifiziert robuste Kandidaten, die in beiden Teststrategien signifikant sind.

```{r}
#| label: wald-lrt-overlap
#| echo: false
#| warning: false

# LRT-Gene (bereits mit ensembl_id)
genes_lrt <- unique(sig_lrt$ensembl_id)

# Wald-Gene pro Kontrast (nutzt sig_results Liste)
genes_wald <- lapply(sig_results, function(sig) {
  unique(strip_ensembl_version(sig$gene))
})
genes_wald_any <- unique(unlist(genes_wald))

# Overlap berechnen
overlap_genes <- lapply(genes_wald, function(g) intersect(genes_lrt, g))
overlap_genes_any_wald <- intersect(genes_lrt, genes_wald_any)
genes_lrt_only  <- setdiff(genes_lrt, genes_wald_any)
genes_wald_only <- setdiff(genes_wald_any, genes_lrt)

# Zusammenfassung
overlap_summary <- tibble(
  category = c("LRT signifikant", "Wald signifikant (any)",
               paste0("LRT ‚à© ", gsub("_", " ", names(overlap_genes))),
               "LRT ‚à© any Wald", "Nur LRT", "Nur Wald"),
  n_genes = c(length(genes_lrt), length(genes_wald_any),
              sapply(overlap_genes, length),
              length(overlap_genes_any_wald), length(genes_lrt_only), length(genes_wald_only))
)
overlap_summary

# Overlap-Gene annotiert (Top 20)
overlap_annot_any_wald <- res_lrt_annot |>
  dplyr::filter(ensembl_id %in% overlap_genes_any_wald) |>
  dplyr::select(ensembl_id, SYMBOL, GENENAME, pvalue, padj) |>
  arrange(padj)

overlap_annot_any_wald |> slice_head(n = 20)

# Overlap nach Kontrast
overlap_by_contrast <- tibble(
  contrast = gsub("_", " ", names(overlap_genes)),
  n_overlap = sapply(overlap_genes, length)
)
overlap_by_contrast
```

## Overlap-Heatmap

Heatmap der Wald‚à©LRT-Overlap-Gene (robuste Kandidaten). Diese Gene √§ndern sich sowohl global (LRT) als auch in mindestens einem paarweisen Kontrast (Wald) signifikant.

```{r}
#| label: overlap-heatmap
#| echo: false
#| warning: false

# Matrix f√ºr Overlap-Gene
mat_overlap <- normalized_counts[
  strip_ensembl_version(rownames(normalized_counts)) %in% overlap_genes_any_wald, , drop = FALSE
]
rownames(mat_overlap) <- strip_ensembl_version(rownames(mat_overlap))
mat_overlap <- mat_overlap[intersect(overlap_genes_any_wald, rownames(mat_overlap)), , drop = FALSE]

# Auf max 200 Gene begrenzen
if (nrow(mat_overlap) > n_heatmap) {
  mat_overlap <- mat_overlap[seq_len(n_heatmap), , drop = FALSE]
}

# Annotation (nutzt annotation_col aus lrt-visualization falls vorhanden)
if (!exists("annotation_col")) {
  annotation_col <- sample_meta |> dplyr::select(samplename, condition) |> as.data.frame()
  rownames(annotation_col) <- annotation_col$samplename
  annotation_col$samplename <- NULL
}

pheatmap(mat_overlap, color = brewer.pal(6, "YlOrRd"), cluster_rows = TRUE, cluster_cols = TRUE,
         show_rownames = FALSE, annotation_col = annotation_col, border_color = NA,
         fontsize = 10, scale = "row",
         main = paste0("Overlap-Heatmap (LRT ‚à© Wald), n = ", nrow(mat_overlap)))
```

## Pattern-Clustering (DEGreport)

Clustering der Wald‚à©LRT-Overlap-Gene nach zeitlichem Expressionsmuster mittels `degPatterns`. Zeigt typische Zeitverl√§ufe (z.B. transiente Hochregulation bei V1).

```{r}
#| label: pattern-clustering
#| echo: false
#| warning: false
#| fig-width: 10
#| fig-height: 6

# Metadaten f√ºr degPatterns (data.frame mit rownames = Sample-Namen)
meta_deg <- data.frame(
  condition = droplevels(meta$timepoint),
  row.names = rownames(meta)
)

# mat_overlap aus vorherigem Chunk wiederverwenden, Spalten an Metadaten anpassen
mat_pattern <- mat_overlap[, rownames(meta_deg), drop = FALSE]

# Auf max. 500 Gene begrenzen (degPatterns-Performance)
n_pattern_max <- 500
if (nrow(mat_pattern) > n_pattern_max) {
  mat_pattern <- mat_pattern[seq_len(n_pattern_max), , drop = FALSE]
}

# Output-Verzeichnisse
fig_dir <- "../../res/figures"
dir.create(fig_dir, recursive = TRUE, showWarnings = FALSE)

# degPatterns mit Caching
cache_degpatterns <- file.path(cache_dir, "degPatterns_overlap.rds")

if (file.exists(cache_degpatterns)) {
  deg_clusters <- readRDS(cache_degpatterns)
} else {
  deg_clusters <- degPatterns(
    mat_pattern,
    metadata = meta_deg,
    time = "condition",
    minc = 30,
    plot = FALSE
  )
  saveRDS(deg_clusters, cache_degpatterns)
}

# Publikationsreifer Plot
p_pattern <- deg_clusters$plot +
  theme_bw(base_size = 11) +
  labs(
    title = "Temporal expression patterns of LRT ‚à© Wald genes",
    x = "Timepoint",
    y = "Scaled expression (z-score)"
  ) +
  theme(
    strip.background = element_rect(fill = "grey95"),
    panel.grid.minor = element_blank(),
    legend.position = "none"
  )

print(p_pattern)

# Figure speichern
ggsave(file.path(fig_dir, "FIG_degPatterns_clusters.png"), p_pattern, width = 10, height = 6, dpi = 300)
ggsave(file.path(fig_dir, "FIG_degPatterns_clusters.pdf"), p_pattern, width = 10, height = 6)
```

## GO + KEGG ORA Analyse

F√ºhrt GO und KEGG Over-Representation Analysis durch f√ºr alle Kontraste (Wald + LRT). Unterst√ºtzt optionalen Effektgr√∂√üen-Filter (lfc_min). Ergebnisse werden als CSV und RDS in `../../res/functional/` gespeichert.

```{r}
#| label: go-kegg-ora
#| echo: false
#| warning: false

# -----------------------------
# Settings (anpassbar)
# -----------------------------
if (!exists("padj_cutoff")) padj_cutoff <- 0.05

# Effektfilter (du kannst hier 0 / 0.5 / 1 setzen)
lfc_min_default <- 0.5

# Output-Dirs
go_out_dir   <- "../../res/functional/ora_go"
kegg_out_dir <- "../../res/functional/ora_kegg"
dir.create(go_out_dir,   recursive = TRUE, showWarnings = FALSE)
dir.create(kegg_out_dir, recursive = TRUE, showWarnings = FALSE)

# KEGG Organismus
kegg_organism <- "hsa"

# -----------------------------
# Helpers
# -----------------------------
strip_ensembl_version <- function(x) sub("\\..*$", "", x)

.ensure_tbl_results <- function(x) {
  if (inherits(x, "DESeqResults")) {
    x |>
      as.data.frame() |>
      tibble::rownames_to_column(var = "gene") |>
      tibble::as_tibble()
  } else {
    tibble::as_tibble(x)
  }
}

# zentrales Filterverhalten f√ºr Wald (mit lfc_min)
.filter_sig_with_lfc <- function(res_tb,
                                 padj_cutoff = 0.05,
                                 direction = c("all", "up", "down"),
                                 lfc_min = 0,
                                 lfc_col = "log2FoldChange") {
  direction <- match.arg(direction)

  # base filtering
  sig <- res_tb |>
    dplyr::filter(!is.na(padj), padj < padj_cutoff)

  # wenn kein LFC vorhanden -> nur all sinnvoll (LRT)
  if (!lfc_col %in% names(sig)) {
    return(sig)
  }

  # apply effect-size filters
  if (direction == "all") {
    sig <- sig |>
      dplyr::filter(abs(.data[[lfc_col]]) >= lfc_min)
  } else if (direction == "up") {
    sig <- sig |>
      dplyr::filter(.data[[lfc_col]] >= lfc_min)
  } else if (direction == "down") {
    sig <- sig |>
      dplyr::filter(.data[[lfc_col]] <= -lfc_min)
  }

  sig
}

# -----------------------------
# GO ORA (ENSEMBL) with lfc_min
# -----------------------------
.build_go_lists <- function(res_obj, padj_cutoff = 0.05, direction = "all", lfc_min = 0) {
  res_tb <- .ensure_tbl_results(res_obj) |>
    dplyr::filter(!is.na(padj)) |>
    dplyr::mutate(ensembl_id = strip_ensembl_version(gene))

  universe <- unique(res_tb$ensembl_id)

  sig_tb <- .filter_sig_with_lfc(
    res_tb = res_tb,
    padj_cutoff = padj_cutoff,
    direction = direction,
    lfc_min = lfc_min
  )

  sig <- unique(sig_tb$ensembl_id)

  list(universe = universe, sig = sig, has_lfc = "log2FoldChange" %in% names(res_tb))
}

.run_enrichGO <- function(sig_vec, universe_vec, ont = "BP",
                          p_adjust_method = "BH", q_cutoff = 0.05) {
  if (length(sig_vec) < 5) return(NULL)

  clusterProfiler::enrichGO(
    gene          = sig_vec,
    universe      = universe_vec,
    OrgDb         = org.Hs.eg.db,
    keyType       = "ENSEMBL",
    ont           = ont,
    pAdjustMethod = p_adjust_method,
    qvalueCutoff  = q_cutoff,
    readable      = TRUE
  )
}

run_go_ora_set_lfc <- function(res_obj,
                               set_label,
                               padj_cutoff = 0.05,
                               lfc_min = 0,
                               ontologies = c("BP", "MF", "CC"),
                               directions = c("all", "up", "down"),
                               out_dir = go_out_dir,
                               force_recompute = FALSE) {
  res_tb <- .ensure_tbl_results(res_obj)
  has_lfc <- "log2FoldChange" %in% names(res_tb)

  # LRT: nur "all"
  if (!has_lfc) directions <- intersect(directions, "all")

  summary_rows <- list()

  for (ont in ontologies) {
    for (dir in directions) {
      stem <- paste0(
        "GO_", ont, "_", set_label, "_", dir,
        "_padj", format(padj_cutoff, nsmall = 2),
        if (has_lfc) paste0("_lfc", format(lfc_min, nsmall = 2)) else ""
      )

      rds_path <- file.path(out_dir, paste0(stem, ".rds"))
      n_sig_genes <- NA_integer_

      # CACHING: Pr√ºfen ob RDS existiert
      if (file.exists(rds_path) && !force_recompute) {
        message("Lade GO Cache: ", stem)
        ego <- readRDS(rds_path)
        tab <- tryCatch(as.data.frame(ego), error = function(e) NULL)
      } else {
        message("Berechne GO: ", stem)
        lists <- .build_go_lists(
          res_obj = res_obj,
          padj_cutoff = padj_cutoff,
          direction = dir,
          lfc_min = lfc_min
        )
        n_sig_genes <- length(lists$sig)

        ego <- .run_enrichGO(lists$sig, lists$universe, ont = ont)

        # save
        if (!is.null(ego)) {
          tab <- as.data.frame(ego)
          write.csv(tab, file.path(out_dir, paste0(stem, ".csv")), row.names = FALSE)
          saveRDS(ego, rds_path)
        } else {
          tab <- NULL
        }
      }

      # Summary erstellen
      if (!is.null(ego) && !is.null(tab) && nrow(tab) > 0) {
        n_terms <- nrow(tab)
        top_term <- tab$Description[1]
        top_padj <- tab$p.adjust[1]
      } else {
        n_terms <- 0L
        top_term <- NA_character_
        top_padj <- NA_real_
      }

      summary_rows[[length(summary_rows) + 1]] <- tibble::tibble(
        set = set_label,
        ontology = ont,
        direction = dir,
        padj_cutoff = padj_cutoff,
        lfc_min = if (has_lfc) lfc_min else NA_real_,
        n_sig_genes = n_sig_genes,
        n_terms = n_terms,
        top_term = top_term,
        top_term_padj = top_padj
      )
    }
  }

  summary_tbl <- dplyr::bind_rows(summary_rows)

  write.csv(
    summary_tbl,
    file.path(out_dir, paste0(
      "GO_ORA_summary_", set_label,
      "_padj", format(padj_cutoff, nsmall = 2),
      if (has_lfc) paste0("_lfc", format(lfc_min, nsmall = 2)) else "",
      ".csv"
    )),
    row.names = FALSE
  )

  summary_tbl
}

# -----------------------------
# KEGG ORA (ENTREZ) with lfc_min
# -----------------------------
.map_ens_to_entrez <- function(ens_vec) {
  ens_vec <- unique(ens_vec[!is.na(ens_vec)])
  if (length(ens_vec) == 0) return(tibble::tibble(ENSEMBL = character(), ENTREZID = character()))

  suppressMessages(
    clusterProfiler::bitr(
      ens_vec,
      fromType = "ENSEMBL",
      toType   = "ENTREZID",
      OrgDb    = org.Hs.eg.db
    )
  ) |>
    tibble::as_tibble()
}

.build_kegg_lists <- function(res_obj, padj_cutoff = 0.05, direction = "all", lfc_min = 0) {
  res_tb <- .ensure_tbl_results(res_obj) |>
    dplyr::filter(!is.na(padj)) |>
    dplyr::mutate(ensembl_id = strip_ensembl_version(gene))

  # Universe ENSEMBL -> ENTREZ
  universe_ens <- unique(res_tb$ensembl_id)
  map_univ <- .map_ens_to_entrez(universe_ens)
  universe_entrez <- unique(map_univ$ENTREZID)

  # Sig genes with lfc_min
  sig_tb <- .filter_sig_with_lfc(
    res_tb = res_tb,
    padj_cutoff = padj_cutoff,
    direction = direction,
    lfc_min = lfc_min
  )

  sig_ens <- unique(sig_tb$ensembl_id)
  map_sig <- .map_ens_to_entrez(sig_ens)
  sig_entrez <- unique(map_sig$ENTREZID)

  list(universe = universe_entrez, sig = sig_entrez, has_lfc = "log2FoldChange" %in% names(res_tb))
}

.run_enrichKEGG <- function(sig_entrez, universe_entrez, organism = "hsa",
                            p_adjust_method = "BH",
                            pvalue_cutoff = 0.05,
                            qvalue_cutoff = 0.05) {
  if (length(sig_entrez) < 5) return(NULL)

  suppressMessages(
    clusterProfiler::enrichKEGG(
      gene          = sig_entrez,
      universe      = universe_entrez,
      organism      = organism,
      pAdjustMethod = p_adjust_method,
      pvalueCutoff  = pvalue_cutoff,
      qvalueCutoff  = qvalue_cutoff
    )
  )
}

run_kegg_ora_set_lfc <- function(res_obj,
                                 set_label,
                                 padj_cutoff = 0.05,
                                 lfc_min = 0,
                                 directions = c("all", "up", "down"),
                                 out_dir = kegg_out_dir,
                                 organism = kegg_organism,
                                 force_recompute = FALSE) {
  res_tb <- .ensure_tbl_results(res_obj)
  has_lfc <- "log2FoldChange" %in% names(res_tb)

  # LRT: nur "all"
  if (!has_lfc) directions <- intersect(directions, "all")

  summary_rows <- list()

  for (dir in directions) {
    stem <- paste0(
      "KEGG_", set_label, "_", dir,
      "_padj", format(padj_cutoff, nsmall = 2),
      if (has_lfc) paste0("_lfc", format(lfc_min, nsmall = 2)) else ""
    )

    rds_path <- file.path(out_dir, paste0(stem, ".rds"))
    n_sig_genes_entrez <- NA_integer_

    # CACHING: Pr√ºfen ob RDS existiert
    if (file.exists(rds_path) && !force_recompute) {
      message("Lade KEGG Cache: ", stem)
      ek <- readRDS(rds_path)
      tab <- tryCatch(as.data.frame(ek), error = function(e) NULL)
    } else {
      message("Berechne KEGG: ", stem)
      lists <- .build_kegg_lists(
        res_obj = res_obj,
        padj_cutoff = padj_cutoff,
        direction = dir,
        lfc_min = lfc_min
      )
      n_sig_genes_entrez <- length(lists$sig)

      ek <- .run_enrichKEGG(lists$sig, lists$universe, organism = organism)

      if (!is.null(ek)) {
        tab <- as.data.frame(ek)
        write.csv(tab, file.path(out_dir, paste0(stem, ".csv")), row.names = FALSE)
        saveRDS(ek, rds_path)
      } else {
        tab <- NULL
      }
    }

    # Summary erstellen
    if (!is.null(ek) && !is.null(tab) && nrow(tab) > 0) {
      n_terms <- nrow(tab)
      top_path <- tab$Description[1]
      top_padj <- tab$p.adjust[1]
    } else {
      n_terms <- 0L
      top_path <- NA_character_
      top_padj <- NA_real_
    }

    summary_rows[[length(summary_rows) + 1]] <- tibble::tibble(
      set = set_label,
      direction = dir,
      padj_cutoff = padj_cutoff,
      lfc_min = if (has_lfc) lfc_min else NA_real_,
      n_sig_genes_entrez = n_sig_genes_entrez,
      n_terms = n_terms,
      top_pathway = top_path,
      top_padj = top_padj
    )
  }

  summary_tbl <- dplyr::bind_rows(summary_rows)

  write.csv(
    summary_tbl,
    file.path(out_dir, paste0(
      "KEGG_ORA_summary_", set_label,
      "_padj", format(padj_cutoff, nsmall = 2),
      if (has_lfc) paste0("_lfc", format(lfc_min, nsmall = 2)) else "",
      ".csv"
    )),
    row.names = FALSE
  )

  summary_tbl
}

# ============================================================
# RUN EXAMPLE: lfc_min = 0.5 (empfohlen)
# ============================================================

lfc_min <- lfc_min_default  # z.B. 0, 0.5, 1

# --- GO ---
go_v1_a  <- run_go_ora_set_lfc(res_V1_vs_A_tb,  "Wald_V1_vs_A",  padj_cutoff, lfc_min)
go_v2_a  <- run_go_ora_set_lfc(res_V2_vs_A_tb,  "Wald_V2_vs_A",  padj_cutoff, lfc_min)
go_v2_v1 <- run_go_ora_set_lfc(res_V2_vs_V1_tb, "Wald_V2_vs_V1", padj_cutoff, lfc_min)

lrt_input <- if (exists("res_lrt_tb")) res_lrt_tb else res_lrt
go_lrt <- run_go_ora_set_lfc(lrt_input, "LRT_timepoint", padj_cutoff, lfc_min = 0, directions = "all")

go_all <- dplyr::bind_rows(go_v1_a, go_v2_a, go_v2_v1, go_lrt)
write.csv(
  go_all,
  file.path(go_out_dir, paste0("GO_ORA_summary_ALL_padj", format(padj_cutoff, nsmall = 2),
                               "_lfc", format(lfc_min, nsmall = 2), ".csv")),
  row.names = FALSE
)

# --- KEGG ---
kegg_v1_a  <- run_kegg_ora_set_lfc(res_V1_vs_A_tb,  "Wald_V1_vs_A",  padj_cutoff, lfc_min)
kegg_v2_a  <- run_kegg_ora_set_lfc(res_V2_vs_A_tb,  "Wald_V2_vs_A",  padj_cutoff, lfc_min)
kegg_v2_v1 <- run_kegg_ora_set_lfc(res_V2_vs_V1_tb, "Wald_V2_vs_V1", padj_cutoff, lfc_min)

kegg_lrt <- run_kegg_ora_set_lfc(lrt_input, "LRT_timepoint", padj_cutoff, lfc_min = 0, directions = "all")

kegg_all <- dplyr::bind_rows(kegg_v1_a, kegg_v2_a, kegg_v2_v1, kegg_lrt)
write.csv(
  kegg_all,
  file.path(kegg_out_dir, paste0("KEGG_ORA_summary_ALL_padj", format(padj_cutoff, nsmall = 2),
                                 "_lfc", format(lfc_min, nsmall = 2), ".csv")),
  row.names = FALSE
)

go_all
kegg_all

```

## GO + KEGG Plots

Erstellt Visualisierungen (Dotplots, Emapplots, Cnetplots) aus gecachten ORA-Ergebnissen. L√§dt RDS-Dateien und erzeugt publikationsreife Plots in `../../res/functional/*/plots/`.

```{r}
#| label: go-kegg-plots
#| echo: false
#| warning: false
# -----------------------------
# Defaults falls nicht gesetzt
# -----------------------------
if (!exists("padj_cutoff")) padj_cutoff <- 0.05
if (!exists("lfc_min")) lfc_min <- 0.5   # WICHTIG: auf denselben Wert wie beim ORA-Lauf setzen!
if (!exists("go_out_dir")) go_out_dir <- "../../res/functional/ora_go"
if (!exists("kegg_out_dir")) kegg_out_dir <- "../../res/functional/ora_kegg"

go_plots_dir <- file.path(go_out_dir, "plots")
kegg_plots_dir <- file.path(kegg_out_dir, "plots")
dir.create(go_plots_dir, recursive = TRUE, showWarnings = FALSE)
dir.create(kegg_plots_dir, recursive = TRUE, showWarnings = FALSE)

# Plot-Defaults (anpassen)
show_dot  <- 30
show_emap <- 30
show_cnet <- 5

# GO Ontologies (meist BP im Main, MF/CC optional)
go_ontologies <- c("BP")  # z.B. c("BP","MF","CC")

# -----------------------------
# Helpers
# -----------------------------
strip_ensembl_version <- function(x) sub("\\..*$", "", x)

.ensure_tbl_results <- function(x) {
  if (inherits(x, "DESeqResults")) {
    x |>
      as.data.frame() |>
      tibble::rownames_to_column(var = "gene") |>
      tibble::as_tibble()
  } else {
    tibble::as_tibble(x)
  }
}

# FoldChange Vektor f√ºr GO (names=ENSEMBL ohne Version)
.make_fc_go <- function(res_obj, padj_cutoff, direction, lfc_min = 0) {
  res_tb <- .ensure_tbl_results(res_obj) |>
    dplyr::filter(!is.na(padj)) |>
    dplyr::mutate(ensembl_id = strip_ensembl_version(gene))

  if (!"log2FoldChange" %in% names(res_tb)) return(NULL)

  sig <- res_tb |>
    dplyr::filter(padj < padj_cutoff)

  if (direction == "all") {
    sig <- sig |> dplyr::filter(abs(log2FoldChange) >= lfc_min)
  } else if (direction == "up") {
    sig <- sig |> dplyr::filter(log2FoldChange >= lfc_min)
  } else if (direction == "down") {
    sig <- sig |> dplyr::filter(log2FoldChange <= -lfc_min)
  }

  fc <- sig$log2FoldChange
  names(fc) <- sig$ensembl_id
  fc <- fc[!duplicated(names(fc))]
  fc
}

# FoldChange Vektor f√ºr KEGG (names=ENTREZID)
.make_fc_kegg <- function(res_obj, padj_cutoff, direction, lfc_min = 0) {
  res_tb <- .ensure_tbl_results(res_obj) |>
    dplyr::filter(!is.na(padj)) |>
    dplyr::mutate(ensembl_id = strip_ensembl_version(gene))

  if (!"log2FoldChange" %in% names(res_tb)) return(NULL)

  sig <- res_tb |>
    dplyr::filter(padj < padj_cutoff)

  if (direction == "all") {
    sig <- sig |> dplyr::filter(abs(log2FoldChange) >= lfc_min)
  } else if (direction == "up") {
    sig <- sig |> dplyr::filter(log2FoldChange >= lfc_min)
  } else if (direction == "down") {
    sig <- sig |> dplyr::filter(log2FoldChange <= -lfc_min)
  }

  # Map ENS -> ENTREZ (f√ºr cnetplot bei KEGG)
  map_sig <- suppressMessages(
    clusterProfiler::bitr(
      unique(sig$ensembl_id),
      fromType = "ENSEMBL",
      toType   = "ENTREZID",
      OrgDb    = org.Hs.eg.db
    )
  )

  sig2 <- sig |>
    dplyr::left_join(map_sig, by = c("ensembl_id" = "ENSEMBL")) |>
    dplyr::filter(!is.na(ENTREZID))

  fc <- sig2$log2FoldChange
  names(fc) <- sig2$ENTREZID
  fc <- fc[!duplicated(names(fc))]
  fc
}

# RDS loader (Enrichment Objekt)
.load_rds_enrich <- function(rds_path) {
  if (!file.exists(rds_path)) return(NULL)
  obj <- readRDS(rds_path)
  tab <- tryCatch(as.data.frame(obj), error = function(e) NULL)
  if (is.null(tab) || nrow(tab) == 0) return(NULL)
  obj
}

# pairwise_termsim cache
.get_termsim_cached <- function(enrich_obj, cache_path) {
  if (file.exists(cache_path)) {
    return(readRDS(cache_path))
  }
  ts <- tryCatch(enrichplot::pairwise_termsim(enrich_obj), error = function(e) NULL)
  if (!is.null(ts)) saveRDS(ts, cache_path)
  ts
}

# dotplot helper (lesbar, dynamische H√∂he)
.make_dotplot <- function(enrich_obj, title, show_dot = 30) {
  tab <- as.data.frame(enrich_obj)
  show_dot_local <- min(show_dot, nrow(tab))
  height <- max(7, min(18, 0.28 * show_dot_local))

  p <- suppressWarnings(
    enrichplot::dotplot(enrich_obj, showCategory = show_dot_local) +
      ggplot2::ggtitle(title) +
      ggplot2::scale_y_discrete(labels = \(x) stringr::str_wrap(x, width = 38)) +
      ggplot2::theme_bw() +
      ggplot2::theme(axis.text.y = ggplot2::element_text(size = 9))
  )

  list(plot = p, height = height)
}

# safe ggsave
.save_plot <- function(p, filename, width = 11, height = 7, dpi = 200) {
  ggplot2::ggsave(filename = filename, plot = p, width = width, height = height, dpi = dpi)
}

# -----------------------------
# GO Plot Runner (RDS-first)
# -----------------------------
plot_go_from_rds <- function(set_label,
                             res_obj_for_fc = NULL,
                             directions = c("all", "up", "down"),
                             ontologies = c("BP"),
                             out_dir = go_out_dir,
                             plots_dir = go_plots_dir,
                             padj_cutoff = 0.05,
                             lfc_min = 0) {
  has_lfc <- !is.null(res_obj_for_fc) && ("log2FoldChange" %in% names(.ensure_tbl_results(res_obj_for_fc)))
  if (!has_lfc) directions <- intersect(directions, "all")

  for (ont in ontologies) {
    for (dir in directions) {
      stem <- paste0(
        "GO_", ont, "_", set_label, "_", dir,
        "_padj", format(padj_cutoff, nsmall = 2),
        if (has_lfc) paste0("_lfc", format(lfc_min, nsmall = 2)) else ""
      )
      rds_path <- file.path(out_dir, paste0(stem, ".rds"))
      ego <- .load_rds_enrich(rds_path)
      if (is.null(ego)) {
        message("GO skip (kein RDS/0 Terms): ", stem)
        next
      }

      # 1) dotplot
      dp <- .make_dotplot(ego, title = paste0(stem, " ‚Äì dotplot"), show_dot = show_dot)
      .save_plot(dp$plot, file.path(plots_dir, paste0(stem, "_dotplot.png")),
                 width = 11, height = dp$height)

      # 2) emapplot (cached termsim)
      ts_path <- file.path(out_dir, paste0(stem, "_termsim.rds"))
      ego_ts <- .get_termsim_cached(ego, ts_path)
      if (!is.null(ego_ts)) {
        p_emap <- tryCatch(
          enrichplot::emapplot(ego_ts, showCategory = show_emap) +
            ggplot2::ggtitle(paste0(stem, " ‚Äì emapplot")) +
            ggplot2::theme_void(),
          error = function(e) NULL
        )
        if (!is.null(p_emap)) {
          .save_plot(p_emap, file.path(plots_dir, paste0(stem, "_emapplot.png")),
                     width = 12, height = 9)
        }
      }

      # 3) cnetplot (nur Wald; foldChange)
      if (has_lfc) {
        fc <- .make_fc_go(res_obj_for_fc, padj_cutoff = padj_cutoff, direction = dir, lfc_min = lfc_min)
        if (!is.null(fc) && length(fc) >= 5 && !is.null(ego_ts)) {
          p_cnet <- tryCatch(
            enrichplot::cnetplot(
              ego_ts,
              showCategory = show_cnet,
              foldChange = fc,
              node_label = "category"
            ) +
              ggplot2::ggtitle(paste0(stem, " ‚Äì cnetplot")) +
              ggplot2::theme_void(),
            error = function(e) NULL
          )
          if (!is.null(p_cnet)) {
            .save_plot(p_cnet, file.path(plots_dir, paste0(stem, "_cnetplot.png")),
                       width = 13, height = 9)
          }
        } else {
          message("GO cnet skip (kein FC/termsim): ", stem)
        }
      }
    }
  }

  invisible(TRUE)
}

# -----------------------------
# KEGG Plot Runner (RDS-first)
# -----------------------------
plot_kegg_from_rds <- function(set_label,
                               res_obj_for_fc = NULL,
                               directions = c("all", "up", "down"),
                               out_dir = kegg_out_dir,
                               plots_dir = kegg_plots_dir,
                               padj_cutoff = 0.05,
                               lfc_min = 0) {
  has_lfc <- !is.null(res_obj_for_fc) && ("log2FoldChange" %in% names(.ensure_tbl_results(res_obj_for_fc)))
  if (!has_lfc) directions <- intersect(directions, "all")

  for (dir in directions) {
    stem <- paste0(
      "KEGG_", set_label, "_", dir,
      "_padj", format(padj_cutoff, nsmall = 2),
      if (has_lfc) paste0("_lfc", format(lfc_min, nsmall = 2)) else ""
    )
    rds_path <- file.path(out_dir, paste0(stem, ".rds"))
    ek <- .load_rds_enrich(rds_path)
    if (is.null(ek)) {
      message("KEGG skip (kein RDS/0 Terms): ", stem)
      next
    }

    # 1) dotplot
    dp <- .make_dotplot(ek, title = paste0(stem, " ‚Äì dotplot"), show_dot = show_dot)
    .save_plot(dp$plot, file.path(plots_dir, paste0(stem, "_dotplot.png")),
               width = 11, height = dp$height)

# --- helper: check if emapplot is safe ---------------------------------
.is_emap_safe <- function(x, min_terms = 3) {
  if (is.null(x)) return(FALSE)

  df <- tryCatch(as.data.frame(x), error = function(e) NULL)
  if (is.null(df) || nrow(df) < min_terms) return(FALSE)

  # pairwise_termsim() stores similarity in @termsim for enrichResult objects
  ts <- tryCatch(x@termsim, error = function(e) NULL)
  if (is.null(ts)) return(FALSE)

  # needs at least some finite similarity off-diagonal to make edges
  ts2 <- as.matrix(ts)
  if (nrow(ts2) < min_terms || ncol(ts2) < min_terms) return(FALSE)

  # remove diagonal, check for any finite > 0 similarities
  diag(ts2) <- NA_real_
  ok <- any(is.finite(ts2) & ts2 > 0, na.rm = TRUE)
  ok
}

# 2) emapplot (cached termsim) ‚Äì ROBUST
ts_path <- file.path(out_dir, paste0(stem, "_termsim.rds"))
ek_ts <- .get_termsim_cached(ek, ts_path)

if (.is_emap_safe(ek_ts, min_terms = 3)) {
  p_emap <- tryCatch(
    enrichplot::emapplot(
      ek_ts,
      showCategory = min(show_emap, nrow(as.data.frame(ek_ts))),
      layout = "nicely"
    ) +
      ggplot2::ggtitle(paste0(stem, " ‚Äì emapplot")) +
      ggplot2::theme_void(),
    error = function(e) {
      message("Skip KEGG emapplot (", stem, "): ", conditionMessage(e))
      NULL
    }
  )

  if (!is.null(p_emap)) {
    .save_plot(
      p_emap,
      file.path(plots_dir, paste0(stem, "_emapplot.png")),
      width = 12,
      height = 9
    )
  }
} else {
  message("Skip KEGG emapplot (zu wenige/keine Kanten): ", stem)
}


    # 3) cnetplot (nur Wald; foldChange)
    if (has_lfc) {
      fc <- .make_fc_kegg(res_obj_for_fc, padj_cutoff = padj_cutoff, direction = dir, lfc_min = lfc_min)
      if (!is.null(fc) && length(fc) >= 5 && !is.null(ek_ts)) {
        p_cnet <- tryCatch(
          enrichplot::cnetplot(
            ek_ts,
            showCategory = show_cnet,
            foldChange = fc,
            node_label = "category"
          ) +
            ggplot2::ggtitle(paste0(stem, " ‚Äì cnetplot")) +
            ggplot2::theme_void(),
          error = function(e) NULL
        )
        if (!is.null(p_cnet)) {
          .save_plot(p_cnet, file.path(plots_dir, paste0(stem, "_cnetplot.png")),
                     width = 13, height = 9)
        }
      } else {
        message("KEGG cnet skip (kein FC/termsim): ", stem)
      }
    }
  }

  invisible(TRUE)
}

# ============================================================
# RUN: alle Kontraste (GO + KEGG) aus RDS plotten
# ============================================================

# Wald
plot_go_from_rds("Wald_V1_vs_A",  res_obj_for_fc = res_V1_vs_A_tb,
                 directions = c("all","up","down"), ontologies = go_ontologies,
                 padj_cutoff = padj_cutoff, lfc_min = lfc_min)

plot_go_from_rds("Wald_V2_vs_A",  res_obj_for_fc = res_V2_vs_A_tb,
                 directions = c("all","up","down"), ontologies = go_ontologies,
                 padj_cutoff = padj_cutoff, lfc_min = lfc_min)

plot_go_from_rds("Wald_V2_vs_V1", res_obj_for_fc = res_V2_vs_V1_tb,
                 directions = c("all","up","down"), ontologies = go_ontologies,
                 padj_cutoff = padj_cutoff, lfc_min = lfc_min)

# LRT (nur all; kein FC)
lrt_input <- if (exists("res_lrt_tb")) res_lrt_tb else res_lrt
plot_go_from_rds("LRT_timepoint", res_obj_for_fc = NULL,
                 directions = c("all"), ontologies = go_ontologies,
                 padj_cutoff = padj_cutoff, lfc_min = 0)

# KEGG
plot_kegg_from_rds("Wald_V1_vs_A",  res_obj_for_fc = res_V1_vs_A_tb,
                   directions = c("all","up","down"),
                   padj_cutoff = padj_cutoff, lfc_min = lfc_min)

plot_kegg_from_rds("Wald_V2_vs_A",  res_obj_for_fc = res_V2_vs_A_tb,
                   directions = c("all","up","down"),
                   padj_cutoff = padj_cutoff, lfc_min = lfc_min)

plot_kegg_from_rds("Wald_V2_vs_V1", res_obj_for_fc = res_V2_vs_V1_tb,
                   directions = c("all","up","down"),
                   padj_cutoff = padj_cutoff, lfc_min = lfc_min)

plot_kegg_from_rds("LRT_timepoint", res_obj_for_fc = NULL,
                   directions = c("all"),
                   padj_cutoff = padj_cutoff, lfc_min = 0)

message("Fertig. GO Plots:   ", normalizePath(go_plots_dir))
message("Fertig. KEGG Plots: ", normalizePath(kegg_plots_dir))

```

## Publikationsreife Multi-Panel Figure

Erstellt eine kombinierte Figure mit GO-Dotplots, KEGG-Dotplots und Pathway-Heatmap f√ºr V1 vs A und V2 vs V1. Einheitliche Farbskalen und optimiertes Layout f√ºr Publikationen.

```{r}
#| label: fig-publication-go-kegg
#| echo: false
#| warning: false
#| fig-width: 20
#| fig-height: 14

# -----------------------------
# 0) Settings
# -----------------------------
padj_cutoff <- if (exists("padj_cutoff")) padj_cutoff else 0.05
lfc_min     <- if (exists("lfc_min")) lfc_min else 0.5

go_out_dir   <- if (exists("go_out_dir")) go_out_dir else "../../res/functional/ora_go"
kegg_out_dir <- if (exists("kegg_out_dir")) kegg_out_dir else "../../res/functional/ora_kegg"

fig_out_dir  <- "../../res/figures"
dir.create(fig_out_dir, recursive = TRUE, showWarnings = FALSE)

# Plot-Parameter
n_category    <- 8        # Anzahl GO/KEGG Terms pro Panel
padj_limits   <- c(1e-12, 0.05)  # Einheitliche Farbskala
dot_size_range <- c(2, 8)        # Punktgr√∂√üen
term_wrap_width <- 35            # Zeilenumbruch f√ºr Term-Labels

# Titel
title_main    <- "TAVI-associated immune trajectory (A ‚Üí V1 ‚Üí V2)"
subtitle_main <- paste0("GO/KEGG ORA (padj < ", padj_cutoff, ", |log2FC| ‚â• ", lfc_min, ")")

# -----------------------------
# 1) Helper-Funktionen
# -----------------------------
fmt2 <- function(x) format(x, nsmall = 2)

stem_go <- function(ont, set_label, dir, padj_cutoff, lfc_min) {

  paste0("GO_", ont, "_", set_label, "_", dir, "_padj", fmt2(padj_cutoff), "_lfc", fmt2(lfc_min))
}

stem_kegg <- function(set_label, dir, padj_cutoff, lfc_min) {
  paste0("KEGG_", set_label, "_", dir, "_padj", fmt2(padj_cutoff), "_lfc", fmt2(lfc_min))
}

safe_read_rds <- function(path) {
  if (!file.exists(path)) return(NULL)
  obj <- tryCatch(readRDS(path), error = function(e) NULL)
  df  <- tryCatch(as.data.frame(obj), error = function(e) NULL)
  if (is.null(df) || nrow(df) == 0) return(NULL)
  obj
}

# Verbesserter Dotplot mit einheitlicher Skala und besserem Wrapping
pub_dotplot <- function(enrich_obj, title, n_cat = n_category,
                        padj_lim = padj_limits, wrap_width = term_wrap_width) {

  # Fallback f√ºr leere/fehlende Daten

  if (is.null(enrich_obj)) {
    return(
      ggplot() +
        annotate("text", x = 0.5, y = 0.5, label = "No enriched terms",
                 size = 4, color = "grey50") +
        theme_void() +
        ggtitle(title) +
        theme(plot.title = element_text(size = 11, face = "bold", hjust = 0.5))
    )
  }

  df <- as.data.frame(enrich_obj)
  if (nrow(df) == 0) {
    return(
      ggplot() +
        annotate("text", x = 0.5, y = 0.5, label = "No enriched terms",
                 size = 4, color = "grey50") +
        theme_void() +
        ggtitle(title) +
        theme(plot.title = element_text(size = 11, face = "bold", hjust = 0.5))
    )
  }

  # Top n_cat Terms

  df_top <- df %>%
    slice_head(n = n_cat) %>%
    mutate(
      Description = str_wrap(Description, width = wrap_width),
      Description = factor(Description, levels = rev(Description)),
      GeneRatio_num = sapply(strsplit(GeneRatio, "/"), function(x) as.numeric(x[1]) / as.numeric(x[2]))
    )

  ggplot(df_top, aes(x = GeneRatio_num, y = Description)) +
    geom_point(aes(size = Count, color = p.adjust)) +
    scale_color_gradient(
      low = "#d73027", high = "#4575b4",
      trans = "log10",
      limits = padj_lim,
      oob = scales::squish,
      name = "p.adjust"
    ) +
    scale_size_continuous(range = dot_size_range, name = "Count") +
    labs(x = "Gene Ratio", y = NULL, title = title) +
    theme_bw(base_size = 10) +
    theme(
      plot.title = element_text(size = 11, face = "bold"),
      axis.text.y = element_text(size = 9),
      axis.text.x = element_text(size = 8),
      legend.position = "right",
      legend.key.size = unit(0.4, "cm"),
      legend.title = element_text(size = 8),
      legend.text = element_text(size = 7),
      panel.grid.minor = element_blank()
    )
}

# Gene aus ORA-Ergebnissen extrahieren
get_top_genes_from_enrich <- function(enrich_obj, n_terms = 3) {
  if (is.null(enrich_obj)) return(list(genes = character(), terms = character()))
  df <- tryCatch(as.data.frame(enrich_obj), error = function(e) NULL)
  if (is.null(df) || nrow(df) == 0) return(list(genes = character(), terms = character()))

  df_top <- df %>% slice_head(n = min(n_terms, nrow(df)))

  genes <- unlist(strsplit(df_top$geneID, "/", fixed = TRUE), use.names = FALSE)
  genes <- unique(genes[!is.na(genes) & genes != ""])
  terms <- df_top$Description

  list(genes = genes, terms = terms)
}

# -----------------------------
# 2) ORA RDS laden - EINHEITLICHE Vergleiche: V1 vs A + V2 vs V1
# -----------------------------
# GO BP
go_v1a_up    <- safe_read_rds(file.path(go_out_dir, paste0(stem_go("BP", "Wald_V1_vs_A", "up", padj_cutoff, lfc_min), ".rds")))
go_v1a_down  <- safe_read_rds(file.path(go_out_dir, paste0(stem_go("BP", "Wald_V1_vs_A", "down", padj_cutoff, lfc_min), ".rds")))
go_v2v1_up   <- safe_read_rds(file.path(go_out_dir, paste0(stem_go("BP", "Wald_V2_vs_V1", "up", padj_cutoff, lfc_min), ".rds")))
go_v2v1_down <- safe_read_rds(file.path(go_out_dir, paste0(stem_go("BP", "Wald_V2_vs_V1", "down", padj_cutoff, lfc_min), ".rds")))

# KEGG - GLEICHE Vergleiche wie GO
kegg_v1a_up    <- safe_read_rds(file.path(kegg_out_dir, paste0(stem_kegg("Wald_V1_vs_A", "up", padj_cutoff, lfc_min), ".rds")))
kegg_v1a_down  <- safe_read_rds(file.path(kegg_out_dir, paste0(stem_kegg("Wald_V1_vs_A", "down", padj_cutoff, lfc_min), ".rds")))
kegg_v2v1_up   <- safe_read_rds(file.path(kegg_out_dir, paste0(stem_kegg("Wald_V2_vs_V1", "up", padj_cutoff, lfc_min), ".rds")))
kegg_v2v1_down <- safe_read_rds(file.path(kegg_out_dir, paste0(stem_kegg("Wald_V2_vs_V1", "down", padj_cutoff, lfc_min), ".rds")))

# -----------------------------
# 3) Dotplots erstellen
# -----------------------------
p_go_v1a_up    <- pub_dotplot(go_v1a_up,    "GO BP: V1 vs A (UP)")
p_go_v1a_down  <- pub_dotplot(go_v1a_down,  "GO BP: V1 vs A (DOWN)")
p_go_v2v1_up   <- pub_dotplot(go_v2v1_up,   "GO BP: V2 vs V1 (UP)")
p_go_v2v1_down <- pub_dotplot(go_v2v1_down, "GO BP: V2 vs V1 (DOWN)")

p_kegg_v1a_up    <- pub_dotplot(kegg_v1a_up,    "KEGG: V1 vs A (UP)")
p_kegg_v1a_down  <- pub_dotplot(kegg_v1a_down,  "KEGG: V1 vs A (DOWN)")
p_kegg_v2v1_up   <- pub_dotplot(kegg_v2v1_up,   "KEGG: V2 vs V1 (UP)")
p_kegg_v2v1_down <- pub_dotplot(kegg_v2v1_down, "KEGG: V2 vs V1 (DOWN)")

# -----------------------------
# 4) Heatmap mit Pathway-Annotation
# -----------------------------
heat_panel <- NULL

if (!exists("trans") || !exists("meta")) {
  warning("Heatmap: 'trans' oder 'meta' nicht gefunden.")
} else {
  trans_mat <- SummarizedExperiment::assay(trans)

  # Rownames der Matrix: ENSEMBL IDs (ggf. mit Version)
  # Wir strippen die Version f√ºr konsistentes Matching
  trans_rownames_clean <- sub("\\..*$", "", rownames(trans_mat))

  # Gene aus verschiedenen ORA-Quellen mit Pathway-Zuordnung
  # Mehr Terms extrahieren f√ºr robustere Genauswahl
  genes_go_v1a_up    <- get_top_genes_from_enrich(go_v1a_up, n_terms = 3)
  genes_go_v1a_down  <- get_top_genes_from_enrich(go_v1a_down, n_terms = 3)
  genes_go_v2v1_up   <- get_top_genes_from_enrich(go_v2v1_up, n_terms = 3)
  genes_go_v2v1_down <- get_top_genes_from_enrich(go_v2v1_down, n_terms = 3)
  genes_kegg_v1a_up  <- get_top_genes_from_enrich(kegg_v1a_up, n_terms = 2)
  genes_kegg_v1a_down<- get_top_genes_from_enrich(kegg_v1a_down, n_terms = 2)
  genes_kegg_v2v1_up <- get_top_genes_from_enrich(kegg_v2v1_up, n_terms = 2)
  genes_kegg_v2v1_down <- get_top_genes_from_enrich(kegg_v2v1_down, n_terms = 2)

  # Pathway-Annotation aufbauen
  pathway_anno <- dplyr::bind_rows(
    tibble(gene = genes_go_v1a_up$genes, pathway = "GO: V1/A UP"),
    tibble(gene = genes_go_v1a_down$genes, pathway = "GO: V1/A DOWN"),
    tibble(gene = genes_go_v2v1_up$genes, pathway = "GO: V2/V1 UP"),
    tibble(gene = genes_go_v2v1_down$genes, pathway = "GO: V2/V1 DOWN"),
    tibble(gene = genes_kegg_v1a_up$genes, pathway = "KEGG: V1/A UP"),
    tibble(gene = genes_kegg_v1a_down$genes, pathway = "KEGG: V1/A DOWN"),
    tibble(gene = genes_kegg_v2v1_up$genes, pathway = "KEGG: V2/V1 UP"),
    tibble(gene = genes_kegg_v2v1_down$genes, pathway = "KEGG: V2/V1 DOWN")
  ) %>%
    dplyr::filter(gene != "") %>%
    dplyr::distinct(gene, .keep_all = TRUE)

  genes_raw <- unique(pathway_anno$gene)
  message("Heatmap: ", length(genes_raw), " unique genes from ORA")

  # Alle Gene als SYMBOL behandeln (readable=TRUE in enrichGO) und zu ENSEMBL mappen
  sym_to_ens_map <- NULL
  if (length(genes_raw) > 0) {
    sym_to_ens_map <- suppressMessages(AnnotationDbi::select(
      org.Hs.eg.db,
      keys = unique(genes_raw),
      columns = c("ENSEMBL"),
      keytype = "SYMBOL"
    )) %>%
      dplyr::filter(!is.na(ENSEMBL)) %>%
      dplyr::distinct(SYMBOL, .keep_all = TRUE)

    message("Heatmap: ", nrow(sym_to_ens_map), " genes mapped to ENSEMBL")
  }

  # Finde welche gemappten ENSEMBL IDs in der Matrix vorkommen
  if (!is.null(sym_to_ens_map) && nrow(sym_to_ens_map) > 0) {
    # Match gegen clean rownames (ohne Version)
    genes_in_matrix <- sym_to_ens_map %>%
      dplyr::filter(ENSEMBL %in% trans_rownames_clean)

    message("Heatmap: ", nrow(genes_in_matrix), " genes found in expression matrix")

    if (nrow(genes_in_matrix) >= 5) {
      # Finde die originalen Rownames (mit Version) f√ºr diese Gene
      idx_match <- match(genes_in_matrix$ENSEMBL, trans_rownames_clean)
      genes_present <- rownames(trans_mat)[idx_match]

      # Sample-Sortierung: A -> V1 -> V2
      meta2 <- meta
      meta2$timepoint <- factor(as.character(meta2$timepoint), levels = c("A", "V1", "V2"))
      ord <- order(meta2$timepoint, meta2$pid)

      trans_mat_ord <- trans_mat[, ord, drop = FALSE]

      # Spalten-Annotation
      anno_col <- data.frame(
        timepoint = meta2$timepoint[ord],
        row.names = colnames(trans_mat_ord)
      )

      # Zeilen-Annotation (Pathway) - √ºber SYMBOL joinen
      anno_row_df <- genes_in_matrix %>%
        dplyr::left_join(pathway_anno, by = c("SYMBOL" = "gene")) %>%
        dplyr::mutate(pathway = ifelse(is.na(pathway), "Other", pathway))

      anno_row <- data.frame(
        Pathway = anno_row_df$pathway,
        row.names = genes_present
      )

      # Matrix subset
      mat_sub <- trans_mat_ord[genes_present, , drop = FALSE]

      # Rownames auf SYMBOL √§ndern (besser lesbar)
      rownames(mat_sub) <- genes_in_matrix$SYMBOL
      rownames(anno_row) <- genes_in_matrix$SYMBOL

      # Farben f√ºr Pathways
      all_pathways <- unique(anno_row$Pathway)
      pathway_colors <- c(
        "GO: V1/A UP" = "#e41a1c",
        "GO: V1/A DOWN" = "#377eb8",
        "GO: V2/V1 UP" = "#ff7f00",
        "GO: V2/V1 DOWN" = "#984ea3",
        "KEGG: V1/A UP" = "#4daf4a",
        "KEGG: V1/A DOWN" = "#f781bf",
        "KEGG: V2/V1 UP" = "#a65628",
        "KEGG: V2/V1 DOWN" = "#999999",
        "Other" = "grey70"
      )

      timepoint_colors <- c("A" = "#66c2a5", "V1" = "#fc8d62", "V2" = "#8da0cb")

      anno_colors <- list(
        timepoint = timepoint_colors,
        Pathway = pathway_colors[all_pathways]
      )

      # pheatmap erstellen
      ph <- pheatmap::pheatmap(
        mat_sub,
        scale = "row",
        annotation_col = anno_col,
        annotation_row = anno_row,
        annotation_colors = anno_colors,
        cluster_cols = FALSE,
        cluster_rows = TRUE,
        show_colnames = FALSE,
        fontsize_row = 7,
        fontsize = 9,
        color = colorRampPalette(c("#4575b4", "white", "#d73027"))(100),
        border_color = NA,
        main = paste0("Top ORA genes (n=", nrow(mat_sub), ", row-scaled VST)"),
        silent = TRUE
      )

      heat_panel <- patchwork::wrap_elements(grid::grid.grabExpr(print(ph)))
      message("Heatmap: Successfully created with ", nrow(mat_sub), " genes")
    } else {
      warning("Heatmap: Only ", nrow(genes_in_matrix), " genes found in matrix (need >= 5)")
    }
  } else {
    warning("Heatmap: No genes could be mapped to ENSEMBL")
  }
}

# Fallback Heatmap
if (is.null(heat_panel)) {
  heat_panel <- ggplot() +
    annotate("text", x = 0.5, y = 0.5, label = "Heatmap\n(insufficient data)",
             size = 5, color = "grey50") +
    theme_void() +
    ggtitle("Gene Expression Heatmap") +
    theme(plot.title = element_text(size = 11, face = "bold", hjust = 0.5))
}

# -----------------------------
# 5) Layout zusammenbauen
# -----------------------------
# GO Block (2x2)
go_row1 <- p_go_v1a_up + p_go_v1a_down
go_row2 <- p_go_v2v1_up + p_go_v2v1_down

# KEGG Block (2x2)
kegg_row1 <- p_kegg_v1a_up + p_kegg_v1a_down
kegg_row2 <- p_kegg_v2v1_up + p_kegg_v2v1_down

# Linke Spalte: GO (2 Zeilen) + KEGG (2 Zeilen) = 4 Zeilen
left_col <- (go_row1 / go_row2 / kegg_row1 / kegg_row2) +
  ggplot2::plot_layout(heights = c(1, 1, 1, 1), guides = "collect") &
  theme(legend.position = "right")

# Gesamtfigur: Links (4 Zeilen Dotplots) | Rechts (Heatmap)
fig <- (left_col | heat_panel) +
  plot_layout(widths = c(2.5, 1)) +
  plot_annotation(
    title = title_main,
    subtitle = subtitle_main,
    tag_levels = "A",
    theme = theme(
      plot.title = element_text(size = 16, face = "bold"),
      plot.subtitle = element_text(size = 11, color = "grey30"),
      plot.tag = element_text(size = 14, face = "bold")
    )
  )

print(fig)

# -----------------------------
# 6) Export
# -----------------------------
out_stem <- paste0("FIG_TAVI_GO_KEGG_HEAT_padj", fmt2(padj_cutoff), "_lfc", fmt2(lfc_min), "_pub")
out_base <- file.path(fig_out_dir, out_stem)

ggsave(paste0(out_base, "_v2.pdf"), fig, width = 20, height = 14, device = cairo_pdf)
ggsave(paste0(out_base, "_v2.png"), fig, width = 20, height = 14, dpi = 300)

message("Saved: ", out_base, "_v2.pdf / _v2.png")

```

```{r}
#| label: fig-tavi-story
#| fig-width: 18
#| fig-height: 16
# ============================================================
# STORY FIGURE: TAVI Immune Trajectory
#
# Die biologische Story:
#   Phase 1 (V1 vs A): Akute Entz√ºndung ‚Üë, Adaptive Immunit√§t ‚Üì
#   Phase 2 (V2 vs V1): Entz√ºndung ‚Üì, Immunit√§t erholt sich ‚Üë
#   Phase 3 (V2 vs A): Weitgehend normalisiert
#
# Layout:
#   A) Timeline-Schematic
#   B) V1 vs A UP - Akute Entz√ºndung
#   C) V1 vs A DOWN - Adaptive Immunit√§t supprimiert
#   D) V2 vs V1 DOWN - Entz√ºndung l√∂st sich auf
#   E) V2 vs V1 UP - Immunit√§t erholt sich
#   F) Heatmap - Schl√ºsselgene √ºber alle Zeitpunkte
# ============================================================

# -----------------------------
# 0) Settings
# -----------------------------
padj_cutoff <- 0.05
lfc_min <- 0.5

go_out_dir <- "../../res/functional/ora_go"
fig_out_dir <- "../../res/figures"
dir.create(fig_out_dir, recursive = TRUE, showWarnings = FALSE)

fmt2 <- function(x) format(x, nsmall = 2)

# -----------------------------
# 1) Timeline Schematic Panel
# -----------------------------
create_timeline <- function() {
  # Daten f√ºr Timeline
  timeline_df <- data.frame(
    x = c(1, 2, 3),
    y = c(0, 0, 0),
    label = c("A\n(Baseline)", "V1\n(Post-TAVI)", "V2\n(3 Monate)"),
    phase = c("Baseline", "Acute", "Recovery")
  )


  # Pfeile zwischen Zeitpunkten
  arrows_df <- data.frame(
    x = c(1.15, 2.15),
    xend = c(1.85, 2.85),
    y = c(0, 0),
    yend = c(0, 0),
    label = c("Akute Phase", "Erholungsphase")
  )

  # Biologische Annotationen
  annot_df <- data.frame(
    x = c(1.5, 2.5),
    y = c(0.4, 0.4),
    label = c("Inflammation ‚Üë\nAdaptive Immunity ‚Üì",
              "Inflammation ‚Üì\nImmunity Recovery ‚Üë"),
    color = c("#e41a1c", "#4daf4a")
  )

  ggplot() +
    # Zeitlinie
    geom_segment(aes(x = 0.5, xend = 3.5, y = 0, yend = 0),
                 linewidth = 1.5, color = "grey40") +
    # Zeitpunkte
    geom_point(data = timeline_df, aes(x = x, y = y),
               size = 12, color = c("#66c2a5", "#fc8d62", "#8da0cb")) +
    geom_text(data = timeline_df, aes(x = x, y = y - 0.25, label = label),
              size = 4, fontface = "bold") +
    # Pfeile
    geom_segment(data = arrows_df,
                 aes(x = x, xend = xend, y = y + 0.12, yend = yend + 0.12),
                 arrow = arrow(length = unit(0.3, "cm"), type = "closed"),
                 linewidth = 1.2, color = "grey50") +
    # Biologische Annotationen
    geom_label(data = annot_df, aes(x = x, y = y, label = label),
               fill = c("#fee0d2", "#d9f0d3"), color = "grey20",
               size = 3.2, fontface = "italic", label.padding = unit(0.4, "lines")) +
    # Styling
    coord_cartesian(xlim = c(0.3, 3.7), ylim = c(-0.5, 0.7)) +
    theme_void() +
    labs(title = "TAVI Immune Trajectory: A ‚Üí V1 ‚Üí V2") +
    theme(
      plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
      plot.margin = margin(10, 10, 10, 10)
    )
}

timeline_panel <- create_timeline()

# -----------------------------
# 2) Helper: Dotplot aus RDS
# -----------------------------
stem_go <- function(set_label, dir) {
  paste0("GO_BP_", set_label, "_", dir, "_padj", fmt2(padj_cutoff), "_lfc", fmt2(lfc_min))
}

safe_read_rds <- function(path) {
  if (!file.exists(path)) return(NULL)
  obj <- tryCatch(readRDS(path), error = function(e) NULL)
  df <- tryCatch(as.data.frame(obj), error = function(e) NULL)
  if (is.null(df) || nrow(df) == 0) return(NULL)
  obj
}

# Einheitliche Farben f√ºr die Story
color_inflammation <- "#d73027"  # Rot f√ºr Entz√ºndung
color_immunity_down <- "#4575b4" # Blau f√ºr Immunit√§t runter
color_resolution <- "#1a9850"    # Gr√ºn f√ºr Aufl√∂sung
color_recovery <- "#ff7f00"      # Orange f√ºr Erholung

story_dotplot <- function(enrich_obj, title, subtitle = NULL,
                          accent_color = "grey30", n_cat = 8) {

  if (is.null(enrich_obj)) {
    return(
      ggplot() +
        annotate("text", x = 0.5, y = 0.5, label = "No enriched terms",
                 size = 4, color = "grey50") +
        theme_void() +
        ggtitle(title) +
        theme(plot.title = element_text(size = 11, face = "bold", hjust = 0.5))
    )
  }

  df <- as.data.frame(enrich_obj)
  if (nrow(df) == 0) {
    return(
      ggplot() +
        annotate("text", x = 0.5, y = 0.5, label = "No enriched terms",
                 size = 4, color = "grey50") +
        theme_void() +
        ggtitle(title) +
        theme(plot.title = element_text(size = 11, face = "bold", hjust = 0.5))
    )
  }

  df_top <- df %>%
    dplyr::slice_head(n = n_cat) %>%
    dplyr::mutate(
      Description = str_wrap(Description, width = 40),
      Description = factor(Description, levels = rev(Description)),
      GeneRatio_num = sapply(strsplit(GeneRatio, "/"),
                             function(x) as.numeric(x[1]) / as.numeric(x[2]))
    )

  p <- ggplot(df_top, aes(x = GeneRatio_num, y = Description)) +
    geom_segment(aes(x = 0, xend = GeneRatio_num, y = Description, yend = Description),
                 color = "grey80", linewidth = 0.5) +
    geom_point(aes(size = Count), color = accent_color, alpha = 0.8) +
    scale_size_continuous(range = c(3, 10), name = "Gene\nCount") +
    labs(x = "Gene Ratio", y = NULL, title = title, subtitle = subtitle) +
    theme_minimal(base_size = 10) +
    theme(
      plot.title = element_text(size = 12, face = "bold", color = accent_color),
      plot.subtitle = element_text(size = 9, color = "grey40", face = "italic"),
      axis.text.y = element_text(size = 9),
      axis.text.x = element_text(size = 8),
      legend.position = "right",
      legend.key.size = unit(0.4, "cm"),
      panel.grid.major.y = element_blank(),
      panel.grid.minor = element_blank()
    )

  p
}

# -----------------------------
# 3) Lade die 4 Schl√ºssel-Vergleiche
# -----------------------------
# V1 vs A UP - Akute Entz√ºndung
go_v1a_up <- safe_read_rds(file.path(go_out_dir, paste0(stem_go("Wald_V1_vs_A", "up"), ".rds")))

# V1 vs A DOWN - Adaptive Immunit√§t supprimiert
go_v1a_down <- safe_read_rds(file.path(go_out_dir, paste0(stem_go("Wald_V1_vs_A", "down"), ".rds")))

# V2 vs V1 DOWN - Entz√ºndung l√∂st sich auf
go_v2v1_down <- safe_read_rds(file.path(go_out_dir, paste0(stem_go("Wald_V2_vs_V1", "down"), ".rds")))

# V2 vs V1 UP - Immunit√§t erholt sich
go_v2v1_up <- safe_read_rds(file.path(go_out_dir, paste0(stem_go("Wald_V2_vs_V1", "up"), ".rds")))

# Dotplots erstellen
p_v1a_up <- story_dotplot(go_v1a_up,
                          title = "V1 vs A: Upregulated",
                          subtitle = "Acute inflammatory response",
                          accent_color = color_inflammation)

p_v1a_down <- story_dotplot(go_v1a_down,
                            title = "V1 vs A: Downregulated",
                            subtitle = "Adaptive immunity suppressed",
                            accent_color = color_immunity_down)

p_v2v1_down <- story_dotplot(go_v2v1_down,
                             title = "V2 vs V1: Downregulated",
                             subtitle = "Inflammation resolving",
                             accent_color = color_resolution)

p_v2v1_up <- story_dotplot(go_v2v1_up,
                           title = "V2 vs V1: Upregulated",
                           subtitle = "Immune recovery",
                           accent_color = color_recovery)

# -----------------------------
# 4) Heatmap: Schl√ºsselgene √ºber alle Zeitpunkte
# -----------------------------
heat_panel <- NULL

if (exists("trans") && exists("meta")) {
  trans_mat <- SummarizedExperiment::assay(trans)
  trans_rownames_clean <- sub("\\..*$", "", rownames(trans_mat))

  # Gene aus ORA-Ergebnissen extrahieren
  get_genes <- function(enrich_obj, n_terms = 2) {
    if (is.null(enrich_obj)) return(character())
    df <- tryCatch(as.data.frame(enrich_obj), error = function(e) NULL)
    if (is.null(df) || nrow(df) == 0) return(character())
    df_top <- df %>% dplyr::slice_head(n = min(n_terms, nrow(df)))
    genes <- unlist(strsplit(df_top$geneID, "/", fixed = TRUE))
    unique(genes[!is.na(genes) & genes != ""])
  }

  # Gene aus allen 4 Vergleichen
  genes_inflam <- get_genes(go_v1a_up, 2)
  genes_immun_down <- get_genes(go_v1a_down, 2)
  genes_resolve <- get_genes(go_v2v1_down, 2)
  genes_recovery <- get_genes(go_v2v1_up, 2)

  # Pathway-Annotation
  pathway_anno <- dplyr::bind_rows(
    tibble(gene = genes_inflam, pathway = "Inflammation (V1‚Üë)"),
    tibble(gene = genes_immun_down, pathway = "Immunity (V1‚Üì)"),
    tibble(gene = genes_resolve, pathway = "Resolution (V2‚Üì)"),
    tibble(gene = genes_recovery, pathway = "Recovery (V2‚Üë)")
  ) %>%
    dplyr::filter(gene != "") %>%
    dplyr::distinct(gene, .keep_all = TRUE)

  genes_raw <- unique(pathway_anno$gene)

  # SYMBOL -> ENSEMBL Mapping
  if (length(genes_raw) > 0) {
    sym_to_ens <- suppressMessages(AnnotationDbi::select(
      org.Hs.eg.db,
      keys = unique(genes_raw),
      columns = c("ENSEMBL"),
      keytype = "SYMBOL"
    )) %>%
      dplyr::filter(!is.na(ENSEMBL)) %>%
      dplyr::distinct(SYMBOL, .keep_all = TRUE)

    genes_in_matrix <- sym_to_ens %>%
      dplyr::filter(ENSEMBL %in% trans_rownames_clean)

    if (nrow(genes_in_matrix) >= 10) {
      idx_match <- match(genes_in_matrix$ENSEMBL, trans_rownames_clean)
      genes_present <- rownames(trans_mat)[idx_match]

      # Sample-Sortierung
      meta2 <- meta
      meta2$timepoint <- factor(as.character(meta2$timepoint), levels = c("A", "V1", "V2"))
      ord <- order(meta2$timepoint, meta2$pid)

      trans_mat_ord <- trans_mat[, ord, drop = FALSE]

      # Annotations
      anno_col <- data.frame(
        Timepoint = meta2$timepoint[ord],
        row.names = colnames(trans_mat_ord)
      )

      anno_row_df <- genes_in_matrix %>%
        dplyr::left_join(pathway_anno, by = c("SYMBOL" = "gene")) %>%
        dplyr::mutate(pathway = ifelse(is.na(pathway), "Other", pathway))

      anno_row <- data.frame(
        Phase = anno_row_df$pathway,
        row.names = genes_present
      )

      mat_sub <- trans_mat_ord[genes_present, , drop = FALSE]
      rownames(mat_sub) <- genes_in_matrix$SYMBOL
      rownames(anno_row) <- genes_in_matrix$SYMBOL

      # Farben
      phase_colors <- c(
        "Inflammation (V1‚Üë)" = color_inflammation,
        "Immunity (V1‚Üì)" = color_immunity_down,
        "Resolution (V2‚Üì)" = color_resolution,
        "Recovery (V2‚Üë)" = color_recovery,
        "Other" = "grey70"
      )

      timepoint_colors <- c("A" = "#66c2a5", "V1" = "#fc8d62", "V2" = "#8da0cb")

      anno_colors <- list(
        Timepoint = timepoint_colors,
        Phase = phase_colors[unique(anno_row$Phase)]
      )

      # Heatmap
      ph <- pheatmap::pheatmap(
        mat_sub,
        scale = "row",
        annotation_col = anno_col,
        annotation_row = anno_row,
        annotation_colors = anno_colors,
        cluster_cols = FALSE,
        cluster_rows = TRUE,
        show_colnames = FALSE,
        fontsize_row = 7,
        fontsize = 9,
        color = colorRampPalette(c("#2166ac", "#f7f7f7", "#b2182b"))(100),
        border_color = NA,
        main = paste0("Key genes across timepoints (n=", nrow(mat_sub), ")"),
        silent = TRUE
      )

      heat_panel <- patchwork::wrap_elements(grid::grid.grabExpr(print(ph)))
    }
  }
}

# Fallback
if (is.null(heat_panel)) {
  heat_panel <- ggplot() +
    annotate("text", x = 0.5, y = 0.5, label = "Heatmap\n(insufficient data)",
             size = 5, color = "grey50") +
    theme_void()
}

# -----------------------------
# 5) Layout zusammenbauen
# -----------------------------
# Obere Reihe: Timeline
# Mittlere Reihe: Phase 1 (V1 vs A)
# Untere Reihe: Phase 2 (V2 vs V1)
# Rechts: Heatmap

# Phase 1 Block
phase1_label <- ggplot() +

  annotate("text", x = 0.5, y = 0.5,
           label = "PHASE 1: Acute Response",
           size = 5, fontface = "bold", color = "grey30") +
  theme_void()

phase1_block <- (p_v1a_up | p_v1a_down) +
  patchwork::plot_layout(guides = "collect")

# Phase 2 Block
phase2_label <- ggplot() +
  annotate("text", x = 0.5, y = 0.5,
           label = "PHASE 2: Recovery (3 months)",
           size = 5, fontface = "bold", color = "grey30") +
  theme_void()

phase2_block <- (p_v2v1_down | p_v2v1_up) +
  patchwork::plot_layout(guides = "collect")

# Linke Spalte
left_col <- (timeline_panel / phase1_label / phase1_block / phase2_label / phase2_block) +
  patchwork::plot_layout(heights = c(1.2, 0.2, 2, 0.2, 2))

# Gesamtfigur
fig_story <- (left_col | heat_panel) +
  patchwork::plot_layout(widths = c(2.5, 1)) +
  patchwork::plot_annotation(
    title = "Transcriptomic Response to TAVI: Biphasic Immune Modulation",
    subtitle = paste0("GO Biological Process enrichment (padj < ", padj_cutoff,
                      ", |log2FC| ‚â• ", lfc_min, ") | RNA-seq from peripheral blood"),
    tag_levels = "A",
    theme = theme(
      plot.title = element_text(size = 16, face = "bold"),
      plot.subtitle = element_text(size = 11, color = "grey40"),
      plot.tag = element_text(size = 14, face = "bold")
    )
  )

print(fig_story)

# -----------------------------
# 6) Export
# -----------------------------
out_base <- file.path(fig_out_dir, "FIG_TAVI_immune_trajectory_story")

ggsave(paste0(out_base, ".pdf"), fig_story, width = 18, height = 16, device = cairo_pdf)
ggsave(paste0(out_base, ".png"), fig_story, width = 18, height = 16, dpi = 300)

message("Saved: ", out_base, ".pdf / .png")

```

## Transkriptomische Entz√ºndungs-, Effektoren- und Ribosomen-Scores nach TAVI

Dieser Codeblock berechnet **RNA-basierte Scores**, die zentrale immunologische und zellul√§re Prozesse nach Transkatheter-Aortenklappenimplantation (TAVI) quantifizieren. Ziel ist es, die **St√§rke und Dynamik der systemischen Entz√ºndungsantwort** sowie der nachfolgenden **immunologischen Reprogrammierung** auf Patientenebene abzubilden.

Basierend auf variance-stabilisierter Expression (VST) werden drei biologisch motivierte Signaturen definiert:\
(1) ein **akuter inflammatorischer Score**, der die fr√ºhe angeborene Immunantwort (z. B. neutrophile Aktivierung und Zytokinproduktion) widerspiegelt,\
(2) ein **immunologischer Effektorscore**, der zytotoxische T-/NK-Zell-Programme erfasst, sowie\
(3) ein **ribosomaler Aktivit√§tsscore**, der globale Ver√§nderungen der Proteinbiosynthese als Marker zellul√§ren Stresses und funktioneller Reprogrammierung abbildet.

Die Scores werden f√ºr jedes Sample berechnet, entlang der Zeitpunkte (A ‚Üí V1 ‚Üí V2) visualisiert und erlauben eine **quantitative Beschreibung interindividueller Unterschiede** in der inflammatorischen Antwort auf TAVI. Sie bilden damit die Grundlage f√ºr weiterf√ºhrende Analysen, einschlie√ülich Korrelationen mit klinischen Parametern und der Identifikation potenzieller Biomarker.

```{r}
# ============================================================
# Trajectory-Scores aus ORA-Genen (row-scaled VST) + Plot
#   - verwendet genes_present (ENSG) und trans (VST)
#   - erzeugt pro Sample 3 Scores:
#       * Acute inflammatory score
#       * Immune effector score
#       * Ribosomal activity score
#   - sortiert A -> V1 -> V2
# ============================================================

suppressPackageStartupMessages({
  library(dplyr)
  library(tidyr)
  library(ggplot2)
})

# -----------------------------
# 0) Preconditions
# -----------------------------
stopifnot(exists("trans"), exists("meta"), exists("genes_present"))
stopifnot(length(genes_present) >= 5)

# trans: DESeq2::vst Objekt
mat <- assay(trans)

# Ensembl-Versionen entfernen (sicher)
rownames(mat) <- sub("\\..*$", "", rownames(mat))

# nur Gene, die wirklich da sind
genes_present2 <- intersect(genes_present, rownames(mat))
stopifnot(length(genes_present2) >= 5)

# sicherstellen, dass meta zu mat passt
stopifnot(all(colnames(mat) == rownames(meta)))

meta2 <- meta

# -----------------------------
# 1) Row-scale (z-score pro Gen √ºber Samples)
# -----------------------------
mat_sub <- mat[genes_present2, , drop = FALSE]

# robuste Z-Transformation (keine NA durch SD=0)
row_z <- function(x) {
  s <- stats::sd(x)
  if (is.na(s) || s == 0) return(rep(0, length(x)))
  (x - mean(x)) / s
}
mat_z <- t(apply(mat_sub, 1, row_z))

# ============================================================
# Gene-Sets f√ºr Scores aus ORA-RDS rekonstruieren
#  - Effector:     GO BP Wald_V2_vs_V1 UP (top Terms)
#  - Ribosome:     KEGG Wald_V2_vs_V1 DOWN (top Terms)
#  - Inflammation: KEGG Wald_V2_vs_A  UP (top Terms)
# ============================================================

suppressPackageStartupMessages({
  library(dplyr)
  library(tibble)
  library(clusterProfiler)
  library(org.Hs.eg.db)
  library(AnnotationDbi)
})

# ---- Settings m√ºssen zu deinem ORA-Run passen
padj_cutoff <- if (exists("padj_cutoff")) padj_cutoff else 0.05
lfc_min     <- if (exists("lfc_min")) lfc_min else 0.5

go_out_dir   <- if (exists("go_out_dir")) go_out_dir else "../../res/functional/ora_go"
kegg_out_dir <- if (exists("kegg_out_dir")) kegg_out_dir else "../../res/functional/ora_kegg"

fmt2 <- function(x) format(x, nsmall = 2)

stem_go <- function(ont, set_label, dir, padj_cutoff, lfc_min) {
  paste0("GO_", ont, "_", set_label, "_", dir,
         "_padj", fmt2(padj_cutoff), "_lfc", fmt2(lfc_min))
}
stem_kegg <- function(set_label, dir, padj_cutoff, lfc_min) {
  paste0("KEGG_", set_label, "_", dir,
         "_padj", fmt2(padj_cutoff), "_lfc", fmt2(lfc_min))
}

safe_read_enrich <- function(path) {
  if (!file.exists(path)) return(NULL)
  obj <- tryCatch(readRDS(path), error = function(e) NULL)
  if (is.null(obj)) return(NULL)
  df <- tryCatch(as.data.frame(obj), error = function(e) NULL)
  if (is.null(df) || nrow(df) == 0) return(NULL)
  obj
}

# ---- RDS laden
go_eff_obj <- safe_read_enrich(file.path(go_out_dir,
  paste0(stem_go("BP","Wald_V2_vs_V1","up", padj_cutoff, lfc_min), ".rds")
))
kegg_ribo_obj <- safe_read_enrich(file.path(kegg_out_dir,
  paste0(stem_kegg("Wald_V2_vs_V1","down", padj_cutoff, lfc_min), ".rds")
))
kegg_infl_obj <- safe_read_enrich(file.path(kegg_out_dir,
  paste0(stem_kegg("Wald_V2_vs_A","up", padj_cutoff, lfc_min), ".rds")
))

# ---- helper: geneID-Spalte aus enrich-Result ziehen
# clusterProfiler speichert geneID meist als "ID1/ID2/..."
get_top_geneIDs <- function(enrich_obj, n_terms = 2) {
  if (is.null(enrich_obj)) return(character())
  df <- as.data.frame(enrich_obj)
  if (!"geneID" %in% names(df)) return(character())
  top <- df |> slice_head(n = min(n_terms, nrow(df))) |> pull(geneID)
  unique(unlist(strsplit(top, "/", fixed = TRUE), use.names = FALSE))
}

# ---- helper: geneIDs -> ENSEMBL mappen (robust: ENSG / ENTREZ / SYMBOL)
to_ens <- function(ids) {
  ids <- unique(ids[!is.na(ids) & ids != ""])
  if (length(ids) == 0) return(character())

  # ENSEMBL?
  if (all(grepl("^ENSG", ids))) return(sub("\\..*$", "", ids))

  # reine Zahlen -> ENTREZ?
  if (all(grepl("^[0-9]+$", ids))) {
    m <- AnnotationDbi::select(org.Hs.eg.db,
      keys = ids, keytype = "ENTREZID", columns = "ENSEMBL"
    )
    return(unique(m$ENSEMBL[!is.na(m$ENSEMBL)]))
  }

  # sonst als SYMBOL versuchen
  m <- AnnotationDbi::select(org.Hs.eg.db,
    keys = ids, keytype = "SYMBOL", columns = "ENSEMBL"
  )
  unique(m$ENSEMBL[!is.na(m$ENSEMBL)])
}

# ---- Gene-Sets bauen (als ENSEMBL)
genes_go_eff   <- get_top_geneIDs(go_eff_obj, n_terms = 2)
genes_kegg_ribo<- get_top_geneIDs(kegg_ribo_obj, n_terms = 2)
genes_kegg_sig <- get_top_geneIDs(kegg_infl_obj, n_terms = 2)

genes_go_eff    <- to_ens(genes_go_eff)
genes_kegg_ribo <- to_ens(genes_kegg_ribo)
genes_kegg_sig  <- to_ens(genes_kegg_sig)

# Mini-Diagnostik
message("Effector ENS: ", length(genes_go_eff))
message("Ribosome ENS: ", length(genes_kegg_ribo))
message("Inflammation ENS: ", length(genes_kegg_sig))

# optional anschauen:
# head(genes_go_eff); head(genes_kegg_ribo); head(genes_kegg_sig)


# -----------------------------
# 2) Drei Score-Gruppen definieren
#    (Fallback: wenn du keine saubere Zuordnung hast, nimm 1 Score aus allen Genen,
#     und zwei weitere aus zuf√§lligen Dritteln ‚Äì ABER das wollen wir nicht.
#    -> Besser: wir nehmen die ORA-Quelle erneut:
#       - In deinem Workflow kommen die Gene aus:
#           GO V2vsV1 UP   (Effector)
#           KEGG V2vsV1 DOWN (Ribosome)
#           KEGG V2vsA UP  (Signaling/Inflammation)
#    Falls du die getrennten Listen noch hast: nutze sie.
# -----------------------------

# Wenn du diese Objekte noch hast (aus dem ORA-rebuild):
#   genes_go_eff, genes_kegg_ribo, genes_kegg_sig
# dann benutzen wir sie, sonst definieren wir clean Fallbacks.

have_split_lists <- all(sapply(
  c("genes_go_eff", "genes_kegg_ribo", "genes_kegg_sig"),
  exists
))

if (!have_split_lists) {
  message("Hinweis: genes_go_eff / genes_kegg_ribo / genes_kegg_sig nicht gefunden -> nutze Fallback (alle Gene f√ºr alle Scores).")
  eff_genes  <- genes_present2
  ribo_genes <- genes_present2
  infl_genes <- genes_present2
} else {
  # mappe ggf. SYMBOL/ENTREZ zu ENSEMBL wurde bei dir schon indirekt gemacht,
  # aber die Split-Listen sind typischerweise SYMBOL/ENTREZ.
  # Deshalb: wir bauen Sets √ºber die bereits gemappte ENS-Liste genes_present2
  # indem wir schlicht die pr√§sentierten Gene verwenden, die aus den jeweiligen Quellen stammen:
  # -> am robustesten: wir remappen die Split-Listen wieder nach ENS, falls n√∂tig.
  suppressPackageStartupMessages({
    library(AnnotationDbi)
    library(org.Hs.eg.db)
  })

  to_ens <- function(x) {
    x <- unique(x[!is.na(x) & x != ""])
    if (length(x) == 0) return(character())

    # wenn schon ENSG:
    if (all(grepl("^ENSG", x))) return(sub("\\..*$", "", x))

    # sonst als SYMBOL versuchen
    map <- AnnotationDbi::select(
      org.Hs.eg.db,
      keys = x,
      keytype = "SYMBOL",
      columns = "ENSEMBL"
    )
    unique(map$ENSEMBL[!is.na(map$ENSEMBL)])
  }

  eff_genes  <- intersect(to_ens(genes_go_eff),     genes_present2)
  ribo_genes <- intersect(to_ens(genes_kegg_ribo),  genes_present2)
  infl_genes <- intersect(to_ens(genes_kegg_sig),   genes_present2)

  # Safety: falls ein Set zu klein ist -> fallback auf alle
  if (length(eff_genes)  < 5) eff_genes  <- genes_present2
  if (length(ribo_genes) < 5) ribo_genes <- genes_present2
  if (length(infl_genes) < 5) infl_genes <- genes_present2
}

# -----------------------------
# 3) Scores berechnen (mean z √ºber Gene)
# -----------------------------
score_from_set <- function(mat_z, gene_set) {
  gene_set <- intersect(gene_set, rownames(mat_z))
  if (length(gene_set) == 0) return(rep(NA_real_, ncol(mat_z)))
  colMeans(mat_z[gene_set, , drop = FALSE], na.rm = TRUE)
}

meta2$score_inflammation <- score_from_set(mat_z, infl_genes)
meta2$score_effector     <- score_from_set(mat_z, eff_genes)
meta2$score_ribosome     <- score_from_set(mat_z, ribo_genes)

# Check gegen NA-Flatline
stopifnot(any(!is.na(meta2$score_inflammation)))
stopifnot(any(!is.na(meta2$score_effector)))
stopifnot(any(!is.na(meta2$score_ribosome)))

# -----------------------------
# 4) Plot vorbereiten (A -> V1 -> V2)
# -----------------------------
meta2$timepoint <- factor(as.character(meta2$timepoint), levels = c("A","V1","V2"))

scores_long <- meta2 |>
  dplyr::select(pid, timepoint, score_inflammation, score_effector, score_ribosome) |>
  tidyr::pivot_longer(
    cols = starts_with("score_"),
    names_to = "score",
    values_to = "value"
  ) |>
  dplyr::mutate(
    score = dplyr::recode(score,
      score_inflammation = "Acute inflammatory score",
      score_effector     = "Immune effector score",
      score_ribosome     = "Ribosomal activity score"
    )
  )

p_scores <- ggplot(scores_long, aes(x = timepoint, y = value, group = pid)) +
  geom_line(alpha = 0.25) +
  geom_point(size = 1.2, alpha = 0.6) +
  stat_summary(aes(group = 1), fun = mean, geom = "line", linewidth = 1.0) +
  stat_summary(aes(group = 1), fun = mean, geom = "point", size = 2.0) +
  facet_wrap(~ score, nrow = 1, scales = "free_y") +
  theme_bw(base_size = 11) +
  labs(
    title = "Transcriptomic immune response after TAVI",
    x = NULL,
    y = "Mean row-scaled VST (z-score)"
  ) +
  theme(
    strip.background = element_rect(fill = "grey95"),
    panel.grid.minor = element_blank()
  )

print(p_scores)

# Optional: speichern
# ggsave("../../res/figures/FIG_TAVI_scores_trajectory.png", p_scores, width = 9, height = 3, dpi = 300)
# ggsave("../../res/figures/FIG_TAVI_scores_trajectory.pdf", p_scores, width = 9, height = 3)


```
